# Phase 1: Core Game Mechanics Enhancement
## Work Breakdown Structure (WBS)

**Goal**: Transform prototype into configurable, feature-complete game foundation

---

## 1.0 Development Environment Setup
**Milestone**: Modern development server with hot reload capabilities

### 1.0.1 Vite Development Server Setup
- [x] Create package.json with Vite, Phaser, and development dependencies
- [x] Configure Vite development server on port 5174
- [x] Set up Hot Module Replacement (HMR) for game files
- [x] Configure Vite to serve from single-player/src/ directory
- [x] Add Vite configuration for development and production builds

### 1.0.2 API Proxy Configuration
- [x] Configure Vite dev server to proxy API calls to backend (port 3001)
- [x] Set up proxy for /api/*, /auth/*, and /game-data/* routes
- [x] Configure CORS handling for development environment
- [x] Test API proxy functionality with mock backend responses
- [x] Verify proxy works with config.json loading

### 1.0.3 Development Tooling Integration
- [x] Configure Vite with TypeScript support for future migration
- [x] Set up development server with automatic browser refresh
- [x] Configure source maps for debugging
- [x] Add development console logging and error overlays
- [x] Test HMR functionality with game code changes

### 1.0.4 Build System Preparation
- [x] Configure Vite production build output to dist/ directory
- [x] Set up asset optimization and minification
- [x] Configure build process for static file generation
- [x] Test production build generation
- [x] Verify built files work with nginx static serving

### 1.0.5 Development Environment Testing
- [x] Test Vite dev server startup and hot reload functionality
- [x] Verify game loads correctly in development environment
- [x] Test API proxy with backend communication
- [x] Validate development tools and debugging features
- [x] Ensure development server doesn't conflict with nginx setup

### 1.0.6 PM2 Development Process Management
- [x] Add PM2 ecosystem.dev.config.js with processes for vite (5174) and backend API (3001)
- [x] Configure watch and autorestart for development processes
- [x] Add npm scripts: pm2:dev:start, pm2:dev:restart, pm2:dev:stop, pm2:dev:logs
- [x] Document developer workflow for starting/stopping dev environment
- [x] Verify PM2 managed dev processes run cleanly and recover on changes

---

## 1.1 Configuration System Integration
**Milestone**: Implement config.json loading system

### 1.1.1 Create Config Loading Infrastructure
- [x] Create config loading function in game script
- [x] Add fetch call to load config/config.json at game startup
- [x] Implement async/await pattern for config loading
- [x] Add config loading error handling with console warnings
- [x] Create configLoaded flag to prevent game start before config loads

### 1.1.2 Implement Ship Configuration
- [x] Replace hardcoded ship.maxSpeed (5) with config.ship.maxSpeed
- [x] Replace hardcoded ship.thrust (0.1) with config.ship.thrust
- [x] Replace hardcoded ship.size (20) with config.ship.size
- [x] Replace hardcoded ship health initialization with config.ship.maxHealth
- [x] Update ship object initialization to use config values

### 1.1.3 Implement Projectile Configuration
- [x] Replace hardcoded projectileSpeed (7) with config.projectiles.speed
- [x] Replace hardcoded projectileLife (100) with config.projectiles.life
- [x] Replace hardcoded projectile cooldown with config.projectiles.cooldown
- [x] Update projectile creation to use config values
- [x] Update projectile movement calculations to use config speed

### 1.1.4 Implement Enemy Configuration
- [x] Create enemy type mapping from config.enemies array
- [x] Replace hardcoded baseEnemyTypes with config-loaded enemy types
- [x] Update enemy spawn logic to use config-based enemy selection
- [x] Implement level-based damage scaling using config values
- [x] Update enemy AI parameters (speed, shootInterval, damage values)

### 1.1.5 Implement Game Configuration
- [x] Replace hardcoded scoreToLevelUp (500) with config.game.scoreToLevelUp
- [x] Replace hardcoded minSpawnInterval (60) with config.game.minSpawnInterval
- [x] Replace hardcoded maxSpawnInterval (300) with config.game.maxSpawnInterval
- [x] Update spawn timer calculations to use config values
- [x] Update level progression logic to use config score thresholds

### 1.1.6 Add Runtime Validation and Fallbacks
- [x] Add config schema validation for required fields (define JSON Schema)
- [x] Implement fallback default values for missing config properties
- [x] Add console logging for config loading success/failure
- [x] Create config validation function to check data types
- [x] Add error handling for malformed config.json
- [x] Establish TypeScript baseline (tsconfig with strict true) for future migration
- [x] Create minimal type definitions for Config, ShipConfig, EnemyConfig, ProjectileConfig

---

## 1.2 Control System Refinement
**Milestone**: Update controls to match specification

### 1.2.1 Remove Old Mouse Controls
- [x] Remove existing mousePressed event listener for left mouse button
- [x] Remove mouse button shooting logic from game loop
- [x] Clean up mouse event variables and state tracking
- [x] Remove left mouse button event handling code
- [x] Test that mouse rotation still works independently

### 1.2.2 Implement W Key Thrust Control
- [x] Add W key event listener for keydown/keyup events
- [x] Create thrust state variable (boolean)
- [x] Modify game loop to apply thrust when W is pressed
- [x] Implement continuous acceleration while W is held
- [x] Add thrust deceleration when W is released

### 1.2.3 Implement Spacebar Afterburner Control
- [x] Add spacebar key event listener for keydown/keyup events
- [x] Create afterburner state variable (boolean)
- [x] Modify thrust logic to apply afterburner boost when spacebar pressed
- [x] Implement afterburner energy consumption logic
- [x] Add afterburner release and energy regeneration

### 1.2.4 Update Right Mouse Button Shooting
- [x] Ensure right mouse button shooting works correctly
- [x] Test right mouse button event handling
- [x] Verify projectile creation on right mouse button press
- [x] Confirm shooting works independently of movement controls
- [x] Test rapid firing capability

### 1.2.5 Control System Integration Testing
- [x] Test W key thrust acceleration and deceleration
- [x] Test spacebar afterburner activation and energy management
- [x] Test mouse rotation remains smooth and responsive
- [x] Test right mouse button shooting functionality
- [x] Verify no conflicts between different control inputs

---

## 1.3 Health & Afterburner Systems
**Milestone**: Implement damage and boost mechanics

### 1.3.1 Initialize Health System Variables
- [x] Add currentHealth property to ship object
- [x] Initialize currentHealth to config.ship.maxHealth
- [x] Add afterburnerEnergy property to ship object
- [x] Initialize afterburnerEnergy to config.ship.afterburnerMax
- [x] Add regeneration timer for afterburner energy

### 1.3.2 Implement Damage System
- [x] Add collision detection for enemy projectiles hitting ship
- [x] Implement health reduction on projectile collision
- [x] Add collision detection for enemy ship collisions
- [x] Implement health reduction on enemy collision
- [x] Add game over condition when health reaches zero

### 1.3.3 Implement Afterburner Energy System
- [x] Add energy consumption when spacebar afterburner is active
- [x] Implement energy depletion rate using config.ship.afterburnerDepleteRate
- [x] Add energy regeneration when afterburner is not active
- [x] Implement regeneration rate using config.ship.afterburnerRegenRate
- [x] Prevent afterburner activation when energy is depleted

### 1.3.4 Create Visual Health Indicators
- [x] Design health bar UI element positioning and styling
- [x] Implement health bar rendering in game loop
- [x] Add health percentage calculation and display
- [x] Create color coding for health levels (green/yellow/red)
- [x] Update health bar in real-time during gameplay

### 1.3.5 Create Visual Afterburner Indicators
- [x] Design afterburner bar UI element positioning and styling
- [x] Implement afterburner bar rendering in game loop
- [x] Add energy percentage calculation and display
- [x] Create color coding for energy levels (blue/cyan/white)
- [x] Update afterburner bar in real-time during gameplay

### 1.3.6 Health System Integration Testing
- [x] Test health reduction on enemy projectile hits
- [x] Test health reduction on enemy collisions
- [x] Test game over condition when health depletes
- [x] Test health bar visual updates and color changes
- [x] Verify health system works with config values

### 1.3.7 Afterburner System Integration Testing
- [x] Test afterburner energy consumption during use
- [x] Test afterburner energy regeneration when inactive
- [x] Test afterburner deactivation when energy depleted
- [x] Test afterburner bar visual updates and color changes
- [x] Verify afterburner system works with config values

---

## 1.4 Testing & Validation
**Milestone**: Core mechanics functional and testable

### 1.4.1 Configuration Loading Tests
- [x] Test config.json loads successfully on game startup
- [x] Verify all ship properties load from config
- [x] Verify all projectile properties load from config
- [x] Verify all enemy types load from config
- [x] Verify all game settings load from config

### 1.4.2 Control System Tests
- [x] Test W key thrust provides continuous acceleration
- [x] Test spacebar afterburner provides speed boost
- [x] Test mouse rotation remains smooth and accurate
- [x] Test right mouse button creates projectiles
- [x] Test control combinations work without conflicts

### 1.4.3 Health System Tests
- [x] Test health bar displays correct percentage
- [x] Test health reduction on projectile hits
- [x] Test health reduction on enemy collisions
- [x] Test game over triggers at zero health
- [x] Test health bar color changes appropriately

### 1.4.4 Afterburner System Tests
- [x] Test afterburner bar displays correct energy level
- [x] Test energy depletes during afterburner use
- [x] Test energy regenerates when afterburner inactive
- [x] Test afterburner deactivates when energy depleted
- [x] Test afterburner bar color changes appropriately

### 1.4.5 Integration Testing
- [x] Test full game loop with all systems active
- [x] Verify 60 FPS performance maintained
- [x] Test config changes affect gameplay appropriately
- [x] Test game restart functionality
- [x] Verify no crashes or errors during extended play

### 1.4.6 Error Handling Validation
- [x] Test behavior with missing config.json file
- [x] Test behavior with malformed config.json
- [x] Test behavior with missing config properties
- [x] Verify fallback values work correctly
- [x] Test console error messages are informative

---

## Phase 1 Completion Checklist

### Configuration System
- [x] All hardcoded values replaced with config-loaded values
- [x] Config validation implemented with fallbacks
- [x] Error handling for config loading failures
- [x] Runtime config changes take effect

### Control System
- [x] W key provides thrust acceleration
- [x] Spacebar provides afterburner boost with energy management
- [x] Mouse rotation works smoothly
- [x] Right mouse button shooting functional
- [x] No control conflicts or issues

### Health & Afterburner Systems
- [x] Health system with damage on hits/collisions
- [x] Visual health bar with color coding
- [x] Afterburner energy system with depletion/regeneration
- [x] Visual afterburner bar with color coding
- [x] Game over on health depletion

### Testing & Validation
- [x] All systems load config values correctly
- [x] All controls work as specified
- [x] Health and afterburner systems functional
- [x] No performance issues or crashes
- [x] Error handling works appropriately

---

## Success Criteria
- ✅ Game loads and runs without hardcoded values
- ✅ All controls work as per specification (W, mouse, RMB, spacebar)
- ✅ Health and afterburner systems fully implemented with visuals
- ✅ Config.json drives all game parameters
- ✅ Game maintains 60 FPS performance
- ✅ No crashes or errors during testing
- ✅ Systems work together without conflicts

## Phase 1 Status: ✅ COMPLETE
**All Phase 1 objectives successfully implemented and tested!**

Phase 1 transformed the prototype into a configurable, feature-complete game foundation with:
- Modern Vite development environment with PM2 process management
- External configuration system driving all game parameters
- Refined control system (W thrust, Spacebar afterburner, mouse rotation, RMB shooting)
- Health and afterburner systems with visual feedback
- Comprehensive testing and validation
- Production deployment script ready for minimal footprint deployment

---

## Dependencies
- `config/config.json` file exists and is properly formatted
- Nginx serving game files correctly
- Browser supports modern JavaScript features
- Game canvas renders at expected resolution

---

## Estimated Effort: 2-3 weeks
- Configuration System: 3-4 days
- Control System: 2-3 days
- Health & Afterburner Systems: 4-5 days
- Testing & Validation: 3-4 days
