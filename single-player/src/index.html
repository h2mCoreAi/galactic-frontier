<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Frontier</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            height: 100vh;
            display: flex;
        }

        /* Left sidebar for banner ads */
        .left-sidebar {
            width: 200px;
            background: #111;
            border-right: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-family: Arial, sans-serif;
            font-size: 14px;
            text-align: center;
        }

        /* Game canvas container */
        .game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            display: block;
            height: 100vh;
            width: auto;
            max-width: calc(100vw - 400px); /* Account for both sidebars */
        }

        /* Right sidebar for top scores */
        .right-sidebar {
            width: 200px;
            background: #111;
            border-left: 2px solid #333;
            display: flex;
            flex-direction: column;
            padding: 20px;
            color: white;
            font-family: Arial, sans-serif;
        }

        .right-sidebar h3 {
            margin: 0 0 15px 0;
            color: #00ff00;
            font-size: 18px;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .score-name {
            color: #fff;
        }

        .score-value {
            color: #00ff00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Left sidebar for banner advertisements -->
    <div class="left-sidebar">
        <div>
            <div style="font-size: 16px; margin-bottom: 10px;">Advertisement</div>
            <div style="font-size: 12px; opacity: 0.7;">Banner Space</div>
        </div>
    </div>

    <!-- Game canvas container -->
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Right sidebar for top scores -->
    <div class="right-sidebar">
        <h3>TOP SCORES</h3>
        <div id="topScores">
            <div class="score-item">
                <span class="score-name">PLAYER 1</span>
                <span class="score-value">250</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 2</span>
                <span class="score-value">200</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 3</span>
                <span class="score-value">180</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 4</span>
                <span class="score-value">150</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 5</span>
                <span class="score-value">120</span>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Global config variable
        let config = null;

        // Canvas resize function
        function resizeCanvas() {
            const viewportHeight = window.innerHeight;
            const availableWidth = window.innerWidth - 400; // Subtract sidebar widths (200px each)

            // Set canvas to full height and available width
            canvas.width = Math.max(800, availableWidth); // Minimum width of 800px
            canvas.height = viewportHeight;

            // Update canvas style to match
            canvas.style.width = canvas.width + 'px';
            canvas.style.height = canvas.height + 'px';
        }

        // Initialize canvas size
        resizeCanvas();

        // Handle window resize
        window.addEventListener('resize', resizeCanvas);

        // Function to update top scores display
        function updateTopScores(scores) {
            const topScoresDiv = document.getElementById('topScores');
            if (!topScoresDiv) return;

            topScoresDiv.innerHTML = scores.map((score, index) => `
                <div class="score-item">
                    <span class="score-name">${score.name || `PLAYER ${index + 1}`}</span>
                    <span class="score-value">${score.value || 0}</span>
                </div>
            `).join('');
        }

        // Score persistence functions
        function saveHighScore(finalScore, level) {
            try {
                const highScores = getHighScores();
                const newScore = {
                    score: finalScore,
                    level: level,
                    timestamp: Date.now(),
                    sessionId: Math.random().toString(36).substr(2, 9)
                };

                highScores.push(newScore);
                highScores.sort((a, b) => b.score - a.score);
                highScores.splice(10); // Keep only top 10

                localStorage.setItem('galacticFrontier_highScores', JSON.stringify(highScores));
                console.log('High score saved:', newScore);
                return true;
            } catch (error) {
                console.error('Failed to save high score:', error);
                return false;
            }
        }

        function getHighScores() {
            try {
                const stored = localStorage.getItem('galacticFrontier_highScores');
                return stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.error('Failed to load high scores:', error);
                return [];
            }
        }

        function validateScoreData(score) {
            // Anti-cheat validation
            if (typeof score !== 'number' || score < 0 || score > 100000) {
                console.warn('Invalid score detected:', score);
                return false;
            }
            return true;
        }

        // Initialize top scores display with saved high scores
        function initializeTopScores() {
            const highScores = getHighScores();
            const displayScores = highScores.slice(0, 5).map((hs, index) => ({
                name: `LEVEL ${hs.level}`,
                value: hs.score
            }));

            // Fill with placeholders if not enough scores
            while (displayScores.length < 5) {
                displayScores.push({
                    name: `PLAYER ${displayScores.length + 1}`,
                    value: (5 - displayScores.length) * 50
                });
            }

            updateTopScores(displayScores);
        }

        initializeTopScores();

        let configLoaded = false;

        // Config loading function
        async function loadConfig() {
            try {
                console.log('Loading game configuration...');
                const response = await fetch('/config/config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                config = await response.json();
                console.log('Configuration loaded successfully:', config);
                configLoaded = true;
                return config;
            } catch (error) {
                console.error('Failed to load configuration:', error);
                // Provide fallback defaults
                config = {
                    ship: {
                        maxSpeed: 5,
                        thrust: 0.1,
                        afterburnerBoost: 2,
                        afterburnerMax: 100,
                        afterburnerDepleteRate: 5,
                        afterburnerRegenRate: 1,
                        maxHealth: 100,
                        size: 20
                    },
                    projectiles: {
                        speed: 7,
                        life: 100,
                        fanShotCount: 10,
                        fanShotAngle: 0.1047,
                        cooldown: 10
                    },
                    enemies: [
                        { type: 'small', size: 10, speed: 3, points: 10, shootInterval: 120, projectileDamage: 1.25, collisionDamage: 3.75 },
                        { type: 'medium', size: 15, speed: 2, points: 20, shootInterval: 90, projectileDamage: 2.5, collisionDamage: 7.5 },
                        { type: 'large', size: 25, speed: 1, points: 50, shootInterval: 60, projectileDamage: 5, collisionDamage: 12.5 }
                    ],
                    game: {
                        scoreToLevelUp: 250,
                        minSpawnInterval: 60,
                        maxSpawnInterval: 300,
                        minHealthSpawnInterval: 300,
                        maxHealthSpawnInterval: 600,
                        minFanShotSpawnInterval: 600,
                        maxFanShotSpawnInterval: 1200,
                        healthPowerUpValue: 10,
                        fanShotDuration: 600
                    }
                };
                console.warn('Using fallback configuration');
                configLoaded = true;
                return config;
            }
        }

        // Player ship
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            speed: 0,
            maxSpeed: 5, // Will be replaced with config value
            thrust: 0.1, // Will be replaced with config value
            size: 20, // Will be replaced with config value
            currentHealth: 100, // Will be replaced with config value
            afterburnerEnergy: 100, // Will be replaced with config value
            lastShot: 0
        };

        // Universe coordinates
        let universeX = 0;
        let universeY = 0;

        // Projectiles (player)
        const projectiles = [];
        let projectileSpeed = 7; // Will be replaced with config value
        let projectileLife = 100; // Will be replaced with config value
        let projectileCooldown = 10; // Will be replaced with config value

        // Enemy projectiles
        const enemyProjectiles = [];

        // Enemies
        const enemies = [];
        let spawnTimer = 0;
        let minSpawnInterval = 60; // Will be replaced with config value
        let maxSpawnInterval = 300; // Will be replaced with config value
        let nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
        let baseEnemyTypes = []; // Will be loaded from config

        // Explosions
        const explosions = [];

        // Power-ups
        const powerUps = [];
        let healthPowerUpSpawnTimer = 0;
        let fanShotPowerUpSpawnTimer = 0;
        let nextHealthPowerUpSpawn = 0; // Will be initialized after config load
        let nextFanShotPowerUpSpawn = 0; // Will be initialized after config load

        // Active power-up effects
        let fanShotActive = false;
        let fanShotTimer = 0;

        // Game states
        const GAME_STATES = {
            START: 'start',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };
        let gameState = GAME_STATES.START;

        // Scoreboard and levels
        let score = 0;
        let bulletsFired = 0;
        let bulletsHit = 0;
        let currentLevel = 1;
        let scoreToLevelUp = 500; // Will be replaced with config value

        // Score multiplier system
        let scoreMultiplier = 1.0;
        let comboTimer = 0;
        let comboCount = 0;
        let lastKillTime = 0;

        // Score display enhancement
        let scoreChangeIndicator = null;
        let scoreChangeTimer = 0;
        let lastDisplayedScore = 0;

        // Apply config values to game variables
        function applyConfig() {
            if (!config) return;

            // Ship configuration
            ship.maxSpeed = config.ship.maxSpeed;
            ship.thrust = config.ship.thrust;
            ship.size = config.ship.size;
            ship.currentHealth = config.ship.maxHealth;
            ship.afterburnerEnergy = config.ship.afterburnerMax;

            // Projectile configuration
            projectileSpeed = config.projectiles.speed;
            projectileLife = config.projectiles.life;
            projectileCooldown = config.projectiles.cooldown;

            // Enemy configuration
            baseEnemyTypes = config.enemies;

            // Game configuration
            scoreToLevelUp = config.game.scoreToLevelUp;
            minSpawnInterval = config.game.minSpawnInterval;
            maxSpawnInterval = config.game.maxSpawnInterval;

            // Power-up configuration
            nextHealthPowerUpSpawn = Math.random() * (config.game.maxHealthSpawnInterval - config.game.minHealthSpawnInterval) + config.game.minHealthSpawnInterval;
            nextFanShotPowerUpSpawn = Math.random() * (config.game.maxFanShotSpawnInterval - config.game.minFanShotSpawnInterval) + config.game.minFanShotSpawnInterval;

            console.log('Configuration applied to game variables');
        }

        // Control state variables
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let thrustPressed = false;
        let afterburnerPressed = false;
        let leftMousePressed = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            // Ensure mouse coordinates stay within canvas bounds
            mouseX = Math.max(0, Math.min(mouseX, canvas.width));
            mouseY = Math.max(0, Math.min(mouseY, canvas.height));
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 0) { // Left mouse button
                e.preventDefault(); // Prevent context menu
                leftMousePressed = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 0) { // Left mouse button
                leftMousePressed = false;
            }
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        document.addEventListener('keydown', (e) => {
            if (gameState === GAME_STATES.START) {
                if (e.key === ' ' || e.key === 'Enter') {
                    startGame();
                }
            } else if (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.PAUSED) {
                if (e.key === 'p' || e.key === 'P') {
                    togglePause();
                } else if (gameState === GAME_STATES.PLAYING) {
                    if (e.key === 'w' || e.key === 'W') thrustPressed = true;
                    if (e.key === ' ') {
                        e.preventDefault(); // Prevent page scroll
                        afterburnerPressed = true;
                    }
                }
            } else if (gameState === GAME_STATES.GAME_OVER) {
                if (e.key === 'r' || e.key === 'R') {
                    gameState = GAME_STATES.START;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameState === GAME_STATES.PLAYING) {
                if (e.key === 'w' || e.key === 'W') thrustPressed = false;
                if (e.key === ' ') afterburnerPressed = false;
            }
        });

        // Stars
        const stars = [];
        for (let i = 0; i < 500; i++) {
            stars.push({
                universeX: (Math.random() - 0.5) * 8000,
                universeY: (Math.random() - 0.5) * 8000,
                size: Math.random() * 2 + 1
            });
        }

        function startGame() {
            gameState = GAME_STATES.PLAYING;
            resetGame();
        }

        function resetGame() {
            ship.currentHealth = config ? config.ship.maxHealth : 100;
            ship.afterburnerEnergy = config ? config.ship.afterburnerMax : 100;
            ship.speed = 0;
            ship.angle = 0;
            universeX = 0;
            universeY = 0;
            score = 0;
            bulletsFired = 0;
            bulletsHit = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            enemies.length = 0;
            explosions.length = 0;
            powerUps.length = 0;
            spawnTimer = 0;
            nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
            healthPowerUpSpawnTimer = 0;
            fanShotPowerUpSpawnTimer = 0;
            nextHealthPowerUpSpawn = Math.random() * (config.game.maxHealthSpawnInterval - config.game.minHealthSpawnInterval) + config.game.minHealthSpawnInterval;
            nextFanShotPowerUpSpawn = Math.random() * (config.game.maxFanShotSpawnInterval - config.game.minFanShotSpawnInterval) + config.game.minFanShotSpawnInterval;
            fanShotActive = false;
            fanShotTimer = 0;
            currentLevel = 1;
            gameState = GAME_STATES.PLAYING;
        }

        function endGame() {
            // Save high score before ending game
            if (validateScoreData(score)) {
                saveHighScore(score, currentLevel);
                initializeTopScores(); // Refresh the top scores display
            }
            gameState = GAME_STATES.GAME_OVER;
        }

        function togglePause() {
            if (gameState === GAME_STATES.PLAYING) {
                gameState = GAME_STATES.PAUSED;
            } else if (gameState === GAME_STATES.PAUSED) {
                gameState = GAME_STATES.PLAYING;
            }
        }

        function drawStartScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC FRONTIER', canvas.width / 2, canvas.height / 2 - 100);

            // Instructions
            ctx.font = '20px Arial';
            ctx.fillText('Controls:', canvas.width / 2, canvas.height / 2 - 40);
            ctx.font = '16px Arial';
            ctx.fillText('Mouse Movement - Rotate Ship', canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText('W - Thrust Forward', canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText('Spacebar - Afterburner (Limited Energy)', canvas.width / 2, canvas.height / 2 + 30);
            ctx.fillText('Left Mouse Button - Shoot', canvas.width / 2, canvas.height / 2 + 50);
            ctx.fillText('P - Pause/Resume', canvas.width / 2, canvas.height / 2 + 70);

            // Start prompt
            ctx.font = '24px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('Press SPACEBAR or ENTER to Start', canvas.width / 2, canvas.height / 2 + 100);

            // Version/Config info
            ctx.font = '12px Arial';
            ctx.fillStyle = 'gray';
            ctx.textAlign = 'left';
            ctx.fillText('Phase 1: Core Game Mechanics', 10, canvas.height - 20);
            ctx.textAlign = 'right';
            ctx.fillText('Configuration Loaded', canvas.width - 10, canvas.height - 20);
        }

        function drawPauseScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pause text
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 50);

            // Instructions
            ctx.font = '24px Arial';
            ctx.fillText('Press P to Resume', canvas.width / 2, canvas.height / 2 + 20);

            // Game stats (in arcade style layout)
            ctx.font = '20px Arial';
            ctx.fillText(`LEVEL ${currentLevel}     SCORE ${score}/${scoreToLevelUp}`, canvas.width / 2, canvas.height / 2 + 70);

            // Health and Afterburner bars
            const barWidth = 120;
            const barHeight = 14;
            const barY = canvas.height / 2 + 90;

            // Health bar (left)
            const healthPercent = ship.currentHealth / config.ship.maxHealth;
            const healthBarX = canvas.width / 2 - barWidth - 20;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(healthBarX, barY, barWidth, barHeight);

            let healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
            ctx.fillStyle = healthColor;
            ctx.fillRect(healthBarX, barY, barWidth * healthPercent, barHeight);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(healthBarX, barY, barWidth, barHeight);

            // Afterburner bar (right)
            const energyPercent = ship.afterburnerEnergy / config.ship.afterburnerMax;
            const energyBarX = canvas.width / 2 + 20;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(energyBarX, barY, barWidth, barHeight);

            let energyColor = energyPercent > 0.6 ? '#ffffff' : energyPercent > 0.3 ? '#00ffff' : '#0000ff';
            ctx.fillStyle = energyColor;
            ctx.fillRect(energyBarX, barY, barWidth * energyPercent, barHeight);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(energyBarX, barY, barWidth, barHeight);

            // Stats at bottom
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText(`SHOTS: ${bulletsFired}     ACCURACY: ${bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100).toFixed(1) : 0}%`, canvas.width / 2, canvas.height / 2 + 130);
        }

        function spawnEnemy() {
            const rand = Math.random();
            let type;
            if (rand < 0.5) type = baseEnemyTypes[0];
            else if (rand < 0.8) type = baseEnemyTypes[1];
            else type = baseEnemyTypes[2];

            const levelMultiplier = Math.pow(1.1, currentLevel - 1); // 10% increase per level

            // Level-based scaling for various attributes
            const speedMultiplier = Math.pow(1.05, currentLevel - 1); // 5% speed increase per level
            const healthMultiplier = Math.pow(1.15, currentLevel - 1); // 15% health increase per level (for collision damage)

            const angle = Math.random() * Math.PI * 2;
            const distance = 500;
            enemies.push({
                universeX: universeX + Math.cos(angle) * distance,
                universeY: universeY + Math.sin(angle) * distance,
                angle: 0,
                speed: type.speed * speedMultiplier, // Scaled speed
                size: type.size,
                points: type.points,
                type: type.type,
                shootTimer: Math.random() * type.shootInterval,
                projectileDamage: type.projectileDamage * levelMultiplier, // Scaled projectile damage
                collisionDamage: type.collisionDamage * healthMultiplier, // Scaled collision damage
                level: currentLevel // Track enemy level for behavior modifications
            });
        }

        function updateShip() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            ship.angle = Math.atan2(mouseY - ship.y, mouseX - ship.x);

            // Handle thrust (W key)
            if (thrustPressed) {
                ship.speed = Math.min(ship.speed + ship.thrust, ship.maxSpeed);
            } else {
                ship.speed = Math.max(ship.speed - ship.thrust / 2, 0);
            }

            // Handle afterburner (spacebar) - only if energy available
            let effectiveSpeed = ship.speed;
            if (afterburnerPressed && ship.afterburnerEnergy > 0) {
                effectiveSpeed *= config.ship.afterburnerBoost;
                ship.afterburnerEnergy = Math.max(0, ship.afterburnerEnergy - config.ship.afterburnerDepleteRate);
            } else if (ship.afterburnerEnergy < config.ship.afterburnerMax) {
                ship.afterburnerEnergy = Math.min(config.ship.afterburnerMax, ship.afterburnerEnergy + config.ship.afterburnerRegenRate);
            }

            universeX += Math.cos(ship.angle) * effectiveSpeed;
            universeY += Math.sin(ship.angle) * effectiveSpeed;

            // Handle shooting (left mouse button)
            if (leftMousePressed && ship.lastShot <= 0) {
                if (fanShotActive) {
                    // Fan-shot: fire 10 projectiles in a spread pattern
                    const spreadAngle = config.projectiles.fanShotAngle; // 0.1047 radians (6 degrees)
                    const halfSpread = (config.projectiles.fanShotCount - 1) * spreadAngle / 2;
                    for (let i = 0; i < config.projectiles.fanShotCount; i++) {
                        const angle = ship.angle - halfSpread + (i * spreadAngle);
                        projectiles.push({
                            universeX: universeX,
                            universeY: universeY,
                            angle: angle,
                            life: projectileLife
                        });
                    }
                    bulletsFired += config.projectiles.fanShotCount;
                } else {
                    // Normal shot: single projectile
                    projectiles.push({
                        universeX: universeX,
                        universeY: universeY,
                        angle: ship.angle,
                        life: projectileLife
                    });
                    bulletsFired++;
                }
                ship.lastShot = projectileCooldown;
            }
            if (ship.lastShot > 0) ship.lastShot--;
        }

        // --- Basic Touch Support (maps to existing inputs) ---
        // Prevent default gestures like scroll/zoom over the canvas
        canvas.style.touchAction = 'none';

        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isTouch) {
            const getTouchPos = (t) => {
                const rect = canvas.getBoundingClientRect();
                const x = t.clientX - rect.left;
                const y = t.clientY - rect.top;
                return {
                    x: Math.max(0, Math.min(x, canvas.width)),
                    y: Math.max(0, Math.min(y, canvas.height))
                };
            };

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const t = e.touches[0];
                if (!t) return;
                const { x, y } = getTouchPos(t);
                mouseX = x;
                mouseY = y;
                // Shooting on initial touch
                leftMousePressed = true;
                // Thrust if first touch on left half of canvas
                thrustPressed = x < canvas.width / 2;
                // Afterburner when 2+ fingers
                afterburnerPressed = e.touches.length >= 2;
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const t = e.touches[0];
                if (!t) return;
                const { x, y } = getTouchPos(t);
                mouseX = x;
                mouseY = y;
                thrustPressed = x < canvas.width / 2;
                afterburnerPressed = e.touches.length >= 2;
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (e.touches.length === 0) {
                    leftMousePressed = false;
                    thrustPressed = false;
                    afterburnerPressed = false;
                } else {
                    const t = e.touches[0];
                    if (t) {
                        const { x } = getTouchPos(t);
                        thrustPressed = x < canvas.width / 2;
                    }
                    afterburnerPressed = e.touches.length >= 2;
                }
            }, { passive: false });
        }

        function updateProjectiles() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            // Player projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(p.universeX - e.universeX, p.universeY - e.universeY);
                    if (dist < e.size) {
                        explosions.push({
                            universeX: e.universeX,
                            universeY: e.universeY,
                            radius: 0,
                            life: 20
                        });
                        addScore(e.points, e.type);
                        bulletsHit++;
                        enemies.splice(j, 1);
                        projectiles.splice(i, 1);
                        // Check for level-up
                        if (score >= scoreToLevelUp) {
                            currentLevel++;
                            score = 0; // Reset score for new level
                            enemies.length = 0; // Clear enemies
                            enemyProjectiles.length = 0; // Clear enemy projectiles
                            // Reset combo on level up
                            comboCount = 0;
                            scoreMultiplier = 1.0;
                            comboTimer = 0;
                        }
                        break;
                    }
                }
            }

            // Enemy projectiles
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                const dist = Math.hypot(p.universeX - universeX, p.universeY - universeY);
                if (dist < ship.size) {
                    ship.currentHealth = Math.max(0, ship.currentHealth - p.damage);
                    enemyProjectiles.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateEnemies() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            spawnTimer++;
            if (spawnTimer >= nextSpawn) {
                spawnEnemy();
                spawnTimer = 0;
                // Level-based spawn rate adjustment - enemies spawn more frequently at higher levels
                const spawnRateMultiplier = Math.max(0.3, 1 - (currentLevel - 1) * 0.1); // Minimum 30% of base rate
                const adjustedMinInterval = minSpawnInterval * spawnRateMultiplier;
                const adjustedMaxInterval = maxSpawnInterval * spawnRateMultiplier;
                nextSpawn = Math.random() * (adjustedMaxInterval - adjustedMinInterval) + adjustedMinInterval;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                // Calculate target angle toward player
                const dx = universeX - e.universeX;
                const dy = universeY - e.universeY;
                const targetAngle = Math.atan2(dy, dx);

                // Smooth turning mechanics - gradual rotation toward target
                let angleDiff = targetAngle - e.angle;
                // Normalize angle difference to [-π, π]
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                // Turn rate and behavior based on enemy type
                let turnRate, pursuitMultiplier, shootAccuracy;
                if (e.type === 'small') {
                    turnRate = 0.15; // Fast turning - aggressive
                    pursuitMultiplier = 1.2; // More aggressive pursuit
                    shootAccuracy = 0.9; // Good accuracy
                } else if (e.type === 'medium') {
                    turnRate = 0.1; // Medium turning - balanced
                    pursuitMultiplier = 1.0; // Normal pursuit
                    shootAccuracy = 0.95; // Better accuracy
                } else { // large
                    turnRate = 0.05; // Slow turning - methodical
                    pursuitMultiplier = 0.8; // Less aggressive pursuit
                    shootAccuracy = 1.0; // Perfect accuracy
                }

                // Apply pursuit multiplier to turn rate for behavioral variation
                turnRate *= pursuitMultiplier;
                e.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate);

                // Basic collision avoidance - steer away from nearby enemies
                let avoidX = 0;
                let avoidY = 0;
                for (let j = 0; j < enemies.length; j++) {
                    if (i === j) continue;
                    const other = enemies[j];
                    const dist = Math.hypot(other.universeX - e.universeX, other.universeY - e.universeY);
                    if (dist < 30 && dist > 0) { // Avoid if too close
                        const avoidAngle = Math.atan2(e.universeY - other.universeY, e.universeX - other.universeX);
                        avoidX += Math.cos(avoidAngle) * (30 - dist) * 0.1;
                        avoidY += Math.sin(avoidAngle) * (30 - dist) * 0.1;
                    }
                }

                // Apply movement with collision avoidance
                const moveX = Math.cos(e.angle) + avoidX;
                const moveY = Math.sin(e.angle) + avoidY;
                const moveMagnitude = Math.hypot(moveX, moveY);

                if (moveMagnitude > 0) {
                    e.universeX += (moveX / moveMagnitude) * e.speed;
                    e.universeY += (moveY / moveMagnitude) * e.speed;
                } else {
                    // Fallback if no movement calculated
                    e.universeX += Math.cos(e.angle) * e.speed;
                    e.universeY += Math.sin(e.angle) * e.speed;
                }

                e.shootTimer++;
                if (e.shootTimer >= e.shootInterval) {
                    // Calculate shooting direction toward player with accuracy variation
                    const shootDx = universeX - e.universeX;
                    const shootDy = universeY - e.universeY;
                    const baseShootAngle = Math.atan2(shootDy, shootDx);

                    // Apply accuracy variation based on enemy type
                    let accuracyVariation;
                    if (e.type === 'small') {
                        accuracyVariation = (Math.random() - 0.5) * 0.3; // ±0.15 radians variation
                    } else if (e.type === 'medium') {
                        accuracyVariation = (Math.random() - 0.5) * 0.2; // ±0.1 radians variation
                    } else { // large
                        accuracyVariation = 0; // Perfect accuracy
                    }

                    const shootAngle = baseShootAngle + accuracyVariation;

                    enemyProjectiles.push({
                        universeX: e.universeX,
                        universeY: e.universeY,
                        angle: shootAngle, // Shoot toward player with accuracy variation
                        life: projectileLife,
                        damage: e.projectileDamage
                    });
                    e.shootTimer = 0;
                }

                const dist = Math.hypot(e.universeX - universeX, e.universeY - universeY);
                if (dist < e.size + ship.size) {
                    explosions.push({
                        universeX: e.universeX,
                        universeY: e.universeY,
                        radius: 0,
                        life: 20
                    });
                    ship.currentHealth = Math.max(0, ship.currentHealth - e.collisionDamage);
                    enemies.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateExplosions() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.radius += 2;
                exp.life--;
                if (exp.life <= 0) explosions.splice(i, 1);
            }
        }

        function spawnPowerUp(type) {
            if (!configLoaded) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 300 + 200; // Spawn between 200-500 units from player
            powerUps.push({
                universeX: universeX + Math.cos(angle) * distance,
                universeY: universeY + Math.sin(angle) * distance,
                type: type,
                size: 8,
                life: 600 // Power-ups disappear after 600 frames
            });
        }

        function updateScoreMultiplier() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            comboTimer--;
            if (comboTimer <= 0) {
                comboCount = 0;
                scoreMultiplier = 1.0;
            }

            // Update score change indicator animation
            if (scoreChangeIndicator) {
                scoreChangeIndicator.life--;
                scoreChangeIndicator.alpha = scoreChangeIndicator.life / 60;
                scoreChangeIndicator.y -= 0.5; // Float upward

                if (scoreChangeIndicator.life <= 0) {
                    scoreChangeIndicator = null;
                }
            }
        }

        function addScore(points, enemyType) {
            // Anti-cheat: validate reasonable score values
            if (points < 0 || points > 1000) {
                console.warn('Invalid score value detected:', points);
                return;
            }

            // Combo system: consecutive kills within 1 second increase multiplier
            const currentTime = Date.now();
            const timeSinceLastKill = currentTime - lastKillTime;

            if (timeSinceLastKill < 1000) { // 1 second window for combo
                comboCount++;
                scoreMultiplier = Math.min(5.0, 1.0 + (comboCount * 0.2)); // Max 5x multiplier
                comboTimer = 120; // 2 seconds to maintain combo
            } else {
                comboCount = 1;
                scoreMultiplier = 1.0;
                comboTimer = 120;
            }
            lastKillTime = currentTime;

            const multipliedPoints = Math.floor(points * scoreMultiplier);
            const oldScore = score;
            score += multipliedPoints;

            // Create score change indicator for animations
            scoreChangeIndicator = {
                points: multipliedPoints,
                basePoints: points,
                multiplier: scoreMultiplier,
                x: canvas.width / 2,
                y: 35,
                alpha: 1.0,
                life: 60 // 1 second display
            };
            scoreChangeTimer = 60;

            console.log(`Enemy destroyed: ${enemyType} (${points} pts × ${scoreMultiplier.toFixed(1)} = ${multipliedPoints} pts)`);

            // Check for milestone achievements
            if (score >= 1000 && oldScore < 1000) {
                console.log('🎉 Milestone: 1000 points reached!');
            } else if (score >= 500 && oldScore < 500) {
                console.log('🎉 Milestone: 500 points reached!');
            }
        }

        function updatePowerUps() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            // Update power-up spawn timers
            healthPowerUpSpawnTimer++;
            if (healthPowerUpSpawnTimer >= nextHealthPowerUpSpawn) {
                spawnPowerUp('health');
                healthPowerUpSpawnTimer = 0;
                nextHealthPowerUpSpawn = Math.random() * (config.game.maxHealthSpawnInterval - config.game.minHealthSpawnInterval) + config.game.minHealthSpawnInterval;
            }

            fanShotPowerUpSpawnTimer++;
            if (fanShotPowerUpSpawnTimer >= nextFanShotPowerUpSpawn) {
                spawnPowerUp('fanShot');
                fanShotPowerUpSpawnTimer = 0;
                nextFanShotPowerUpSpawn = Math.random() * (config.game.maxFanShotSpawnInterval - config.game.minFanShotSpawnInterval) + config.game.minFanShotSpawnInterval;
            }

            // Update active power-up effects
            if (fanShotActive) {
                fanShotTimer--;
                if (fanShotTimer <= 0) {
                    fanShotActive = false;
                }
            }

            // Update power-up lifetimes and check collisions
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                p.life--;

                // Check collision with ship
                const dist = Math.hypot(p.universeX - universeX, p.universeY - universeY);
                if (dist < p.size + ship.size) {
                    // Power-up collected
                    if (p.type === 'health') {
                        ship.currentHealth = Math.min(config.ship.maxHealth, ship.currentHealth + config.game.healthPowerUpValue);
                        console.log('Health power-up collected! +10 HP');
                    } else if (p.type === 'fanShot') {
                        // Prevent stacking - reset timer if already active
                        fanShotActive = true;
                        fanShotTimer = config.game.fanShotDuration;
                        console.log('Fan-shot power-up collected! Multi-shot active for 10 seconds');
                    }
                    powerUps.splice(i, 1);
                    continue;
                }

                // Remove expired power-ups
                if (p.life <= 0) {
                    powerUps.splice(i, 1);
                }
            }
        }

        function draw() {
            if (gameState === GAME_STATES.START) {
                drawStartScreen();
                return;
            }

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw game world
            drawGame();

            // Draw pause overlay if paused
            if (gameState === GAME_STATES.PAUSED) {
                drawPauseScreen();
            }
        }

        function drawGame() {

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw projectiles
            ctx.fillStyle = 'white';
            projectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemy projectiles
            ctx.fillStyle = 'orange';
            enemyProjectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemies
            enemies.forEach(e => {
                const screenX = e.universeX - universeX + canvas.width / 2;
                const screenY = e.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(e.angle);
                    ctx.beginPath();
                    if (e.type === 'small') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(-e.size / 2, e.size / 2);
                        ctx.lineTo(-e.size / 2, -e.size / 2);
                    } else if (e.type === 'medium') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(0, e.size / 2);
                        ctx.lineTo(-e.size, 0);
                        ctx.lineTo(0, -e.size / 2);
                    } else {
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            const x = e.size * Math.cos(angle);
                            const y = e.size * Math.sin(angle);
                            ctx[i === 0 ? 'moveTo' : 'lineTo'](x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Draw power-ups
            powerUps.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.save();
                    ctx.translate(screenX, screenY);

                    // Draw power-up based on type
                    if (p.type === 'health') {
                        ctx.fillStyle = '#00ff00'; // Green for health
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        // Draw cross
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-4, 0);
                        ctx.lineTo(4, 0);
                        ctx.moveTo(0, -4);
                        ctx.lineTo(0, 4);
                        ctx.stroke();
                    } else if (p.type === 'fanShot') {
                        ctx.fillStyle = '#ff00ff'; // Magenta for fan-shot
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        // Draw fan pattern
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2) / 5;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(angle) * p.size * 1.5, Math.sin(angle) * p.size * 1.5);
                            ctx.stroke();
                        }
                    }

                    ctx.restore();
                }
            });

            // Draw explosions
            ctx.strokeStyle = 'yellow';
            explosions.forEach(exp => {
                const screenX = exp.universeX - universeX + canvas.width / 2;
                const screenY = exp.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, exp.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw spaceship
            if (gameState === GAME_STATES.PLAYING) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);
                ctx.beginPath();
                ctx.moveTo(ship.size, 0);
                ctx.lineTo(ship.size * 0.3, ship.size * 0.5);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.5);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.3, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, -ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, -ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.restore();
            }

            // Draw scoreboard and UI (only during gameplay)
            if (gameState === GAME_STATES.PLAYING) {
                // Top HUD - Score and Level centered
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`LEVEL ${currentLevel}     SCORE ${score}/${scoreToLevelUp}`, canvas.width / 2, 25);

                // Draw score change indicator
                if (scoreChangeIndicator) {
                    ctx.save();
                    ctx.globalAlpha = scoreChangeIndicator.alpha;
                    ctx.fillStyle = scoreChangeIndicator.multiplier > 1 ? '#00ff00' : 'white';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    const indicatorText = scoreChangeIndicator.multiplier > 1
                        ? `+${scoreChangeIndicator.points} (${scoreChangeIndicator.multiplier.toFixed(1)}x)`
                        : `+${scoreChangeIndicator.points}`;
                    ctx.fillText(indicatorText, scoreChangeIndicator.x, scoreChangeIndicator.y);
                    ctx.restore();
                }

                // Draw combo indicator
                if (comboCount > 1 && comboTimer > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${comboCount}x COMBO!`, canvas.width / 2, 50);
                }

                // Top bars - Health and Afterburner side by side
                const barWidth = 150;
                const barHeight = 16;
                const barY = 40;

                // Health bar (left side)
                const healthPercent = ship.currentHealth / config.ship.maxHealth;
                const healthBarX = 10;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(healthBarX, barY, barWidth, barHeight);

                let healthColor;
                if (healthPercent > 0.6) healthColor = '#00ff00'; // Green
                else if (healthPercent > 0.3) healthColor = '#ffff00'; // Yellow
                else healthColor = '#ff0000'; // Red

                ctx.fillStyle = healthColor;
                ctx.fillRect(healthBarX, barY, barWidth * healthPercent, barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(healthBarX, barY, barWidth, barHeight);

                // Health label
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`HEALTH ${ship.currentHealth.toFixed(0)}/${config.ship.maxHealth}`, healthBarX, barY - 3);

                // Afterburner bar (right side)
                const energyPercent = ship.afterburnerEnergy / config.ship.afterburnerMax;
                const energyBarX = canvas.width - barWidth - 10;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(energyBarX, barY, barWidth, barHeight);

                let energyColor;
                if (energyPercent > 0.6) energyColor = '#ffffff'; // White
                else if (energyPercent > 0.3) energyColor = '#00ffff'; // Cyan
                else energyColor = '#0000ff'; // Blue

                ctx.fillStyle = energyColor;
                ctx.fillRect(energyBarX, barY, barWidth * energyPercent, barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(energyBarX, barY, barWidth, barHeight);

                // Afterburner label
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`AFTERBURNER ${ship.afterburnerEnergy.toFixed(0)}/${config.ship.afterburnerMax}`, energyBarX + barWidth, barY - 3);

                // Fan-shot indicator (when active)
                if (fanShotActive) {
                    const fanShotBarY = barY + 25;
                    const fanShotPercent = fanShotTimer / config.game.fanShotDuration;
                    const fanShotBarX = 10;
                    const fanShotWidth = 80;

                    ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
                    ctx.fillRect(fanShotBarX, fanShotBarY, fanShotWidth, barHeight);

                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(fanShotBarX, fanShotBarY, fanShotWidth * fanShotPercent, barHeight);

                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(fanShotBarX, fanShotBarY, fanShotWidth, barHeight);

                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`FAN-SHOT ${(fanShotTimer / 60).toFixed(1)}s`, fanShotBarX, fanShotBarY - 3);
                }

                // Bottom stats
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`SHOTS: ${bulletsFired}`, 10, canvas.height - 30);
                ctx.fillText(`ACCURACY: ${bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100).toFixed(1) : 0}%`, 10, canvas.height - 10);
            }

            // Game over
            if (gameState === GAME_STATES.GAME_OVER) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
                ctx.font = '20px Arial';
                ctx.fillText(`Final Score: ${score} (Level ${currentLevel})`, canvas.width / 2, canvas.height / 2 + 40);
                ctx.fillText('Press R to Return to Main Menu', canvas.width / 2, canvas.height / 2 + 80);
            }
        }

        function gameLoop() {
            if (gameState === GAME_STATES.PLAYING) {
                updateShip();
                updateProjectiles();
                updateEnemies();
                updateExplosions();
                updatePowerUps();
                updateScoreMultiplier();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('click', () => canvas.focus());
        canvas.tabIndex = 1;

        // Initialize game with config loading
        async function initGame() {
            await loadConfig();
            applyConfig();
            gameLoop(); // Start the render loop, but game stays in START state
        }

        initGame();
    </script>
</body>
</html>