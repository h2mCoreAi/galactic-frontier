<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Frontier</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            height: 100vh;
            display: flex;
        }

        /* Left sidebar for banner ads */
        .left-sidebar {
            width: 200px;
            background: #111;
            border-right: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-family: Arial, sans-serif;
            font-size: 14px;
            text-align: center;
        }

        /* Game canvas container */
        .game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            display: block;
            height: 100vh;
            width: auto;
            max-width: calc(100vw - 400px); /* Account for both sidebars */
        }

        /* Right sidebar for top scores */
        .right-sidebar {
            width: 200px;
            background: #111;
            border-left: 2px solid #333;
            display: flex;
            flex-direction: column;
            padding: 20px;
            color: white;
            font-family: Arial, sans-serif;
        }

        .right-sidebar h3 {
            margin: 0 0 15px 0;
            color: #00ff00;
            font-size: 18px;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .score-name {
            color: #fff;
        }

        .score-value {
            color: #00ff00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Left sidebar for banner advertisements -->
    <div class="left-sidebar">
        <div>
            <div style="font-size: 16px; margin-bottom: 10px;">Advertisement</div>
            <div style="font-size: 12px; opacity: 0.7;">Banner Space</div>
        </div>
    </div>

    <!-- Game canvas container -->
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Right sidebar for top scores -->
    <div class="right-sidebar">
        <h3>TOP SCORES</h3>
        <div id="topScores">
            <div class="score-item">
                <span class="score-name">PLAYER 1</span>
                <span class="score-value">250</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 2</span>
                <span class="score-value">200</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 3</span>
                <span class="score-value">180</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 4</span>
                <span class="score-value">150</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 5</span>
                <span class="score-value">120</span>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Global config variable
        let config = null;

        // Canvas resize function
        function resizeCanvas() {
            const viewportHeight = window.innerHeight;
            const availableWidth = window.innerWidth - 400; // Subtract sidebar widths (200px each)

            // Set canvas to full height and available width
            canvas.width = Math.max(800, availableWidth); // Minimum width of 800px
            canvas.height = viewportHeight;

            // Update canvas style to match
            canvas.style.width = canvas.width + 'px';
            canvas.style.height = canvas.height + 'px';
        }

        // Initialize canvas size
        resizeCanvas();

        // Handle window resize
        window.addEventListener('resize', resizeCanvas);

        // Function to update top scores display
        function updateTopScores(scores) {
            const topScoresDiv = document.getElementById('topScores');
            if (!topScoresDiv) return;

            topScoresDiv.innerHTML = scores.map((score, index) => `
                <div class="score-item">
                    <span class="score-name">${score.name || `PLAYER ${index + 1}`}</span>
                    <span class="score-value">${score.value || 0}</span>
                </div>
            `).join('');
        }

        // Score persistence functions - now supports both local and backend
        let backendAvailable = false;
        let currentSessionId = null;

        // Check if backend is available
        async function checkBackendAvailability() {
            try {
                const response = await fetch('http://localhost:3001/health', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                backendAvailable = response.ok;
                console.log('Backend available:', backendAvailable);
            } catch (error) {
                backendAvailable = false;
                console.log('Backend not available, using local storage');
            }
        }

        // Initialize session when game starts
        async function initializeGameSession() {
            if (backendAvailable) {
                try {
                    const headers = { 'Content-Type': 'application/json' };

                    // Include JWT token if user is authenticated
                    if (authToken) {
                        headers['Authorization'] = `Bearer ${authToken}`;
                    }

                    const response = await fetch('http://localhost:3001/api/sessions/start', {
                        method: 'POST',
                        headers: headers,
                        credentials: 'include'
                    });

                    if (response.ok) {
                        const data = await response.json();
                        currentSessionId = data.session_id;
                        console.log('Session started:', currentSessionId);
                    }
                } catch (error) {
                    console.error('Failed to start session:', error);
                }
            }
        }

        // End session when game ends
        async function endGameSession(finalScore, levelReached, playTime, accuracy) {
            if (backendAvailable && currentSessionId) {
                try {
                    const headers = { 'Content-Type': 'application/json' };

                    // Include JWT token if user is authenticated
                    if (authToken) {
                        headers['Authorization'] = `Bearer ${authToken}`;
                    }

                    const response = await fetch(`http://localhost:3001/api/sessions/${currentSessionId}/end`, {
                        method: 'PUT',
                        headers: headers,
                        credentials: 'include',
                        body: JSON.stringify({
                            score: finalScore,
                            level_reached: levelReached,
                            play_time: playTime,
                            accuracy: accuracy,
                            enemies_defeated: 0 // TODO: track this
                        })
                    });

                    if (response.ok) {
                        console.log('Session ended successfully');
                    }
                } catch (error) {
                    console.error('Failed to end session:', error);
                }
            }
        }

        async function saveHighScore(finalScore, level, playTime = 0, accuracy = 0) {
            try {
                // Always save to local storage as fallback
                const localHighScores = getLocalHighScores();
                const newScore = {
                    score: finalScore,
                    level: level,
                    timestamp: Date.now(),
                    sessionId: currentSessionId || Math.random().toString(36).substr(2, 9),
                    playTime: playTime,
                    accuracy: accuracy
                };

                localHighScores.push(newScore);
                localHighScores.sort((a, b) => b.score - a.score);
                localHighScores.splice(10); // Keep only top 10
                localStorage.setItem('galacticFrontier_highScores', JSON.stringify(localHighScores));

                // Try to save to backend if available
                if (backendAvailable) {
                    try {
                        const headers = { 'Content-Type': 'application/json' };

                        // Include JWT token if user is authenticated
                        if (authToken) {
                            headers['Authorization'] = `Bearer ${authToken}`;
                        }

                        const response = await fetch('http://localhost:3001/api/highscores', {
                            method: 'POST',
                            headers: headers,
                            credentials: 'include',
                            body: JSON.stringify({
                                score: finalScore,
                                level_reached: level,
                                play_time: playTime,
                                accuracy: accuracy,
                                session_id: currentSessionId
                            })
                        });

                        if (response.ok) {
                            console.log('High score saved to backend');
                        } else {
                            console.warn('Failed to save high score to backend:', response.status);
                        }
                    } catch (error) {
                        console.warn('Backend save failed, using local storage only:', error);
                    }
                }

                return true;
            } catch (error) {
                console.error('Failed to save high score:', error);
                return false;
            }
        }

        function getLocalHighScores() {
            try {
                const stored = localStorage.getItem('galacticFrontier_highScores');
                return stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.error('Failed to load local high scores:', error);
                return [];
            }
        }

        async function getHighScores() {
            // Try to get from backend first, fallback to local
            if (backendAvailable) {
                try {
                    const response = await fetch('http://localhost:3001/api/highscores?limit=10', {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include'
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log('Loaded high scores from backend');
                        return data.highscores || [];
                    }
                } catch (error) {
                    console.warn('Failed to load backend high scores:', error);
                }
            }

            // Fallback to local storage
            console.log('Using local high scores');
            return getLocalHighScores();
        }

        function validateScoreData(score) {
            // Anti-cheat validation
            if (typeof score !== 'number' || score < 0 || score > 100000) {
                console.warn('Invalid score detected:', score);
                return false;
            }
            return true;
        }

        // Initialize top scores display with saved high scores
        async function initializeTopScores() {
            const highScores = await getHighScores();
            const displayScores = highScores.slice(0, 5).map((hs, index) => ({
                name: hs.username ? hs.username : `LEVEL ${hs.level || 1}`,
                value: hs.score
            }));

            // Fill with placeholders if not enough scores
            while (displayScores.length < 5) {
                displayScores.push({
                    name: `PLAYER ${displayScores.length + 1}`,
                    value: (5 - displayScores.length) * 50
                });
            }

            updateTopScores(displayScores);
        }

        // Initialize top scores asynchronously
        (async () => {
            await initializeTopScores();
        })();

        let configLoaded = false;

        // Config loading function
        async function loadConfig() {
            try {
                console.log('Loading game configuration...');
                const response = await fetch('/config/config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                config = await response.json();
                console.log('Configuration loaded successfully:', config);
                configLoaded = true;
                return config;
            } catch (error) {
                console.error('Failed to load configuration:', error);
                // Provide fallback defaults
                config = {
                    ship: {
                        maxSpeed: 5,
                        thrust: 0.1,
                        afterburnerBoost: 2,
                        afterburnerMax: 100,
                        afterburnerDepleteRate: 5,
                        afterburnerRegenRate: 1,
                        maxHealth: 100,
                        size: 20
                    },
                    projectiles: {
                        speed: 7,
                        life: 100,
                        fanShotCount: 10,
                        fanShotAngle: 0.1047,
                        cooldown: 10
                    },
                    enemies: [
                        { type: 'small', size: 10, speed: 3, points: 10, shootInterval: 120, projectileDamage: 1.25, collisionDamage: 3.75 },
                        { type: 'medium', size: 15, speed: 2, points: 20, shootInterval: 90, projectileDamage: 2.5, collisionDamage: 7.5 },
                        { type: 'large', size: 25, speed: 1, points: 50, shootInterval: 60, projectileDamage: 5, collisionDamage: 12.5 }
                    ],
                    game: {
                        scoreToLevelUp: 250,
                        minSpawnInterval: 60,
                        maxSpawnInterval: 300,
                        minHealthSpawnInterval: 300,
                        maxHealthSpawnInterval: 600,
                        minFanShotSpawnInterval: 600,
                        maxFanShotSpawnInterval: 1200,
                        healthPowerUpValue: 10,
                        fanShotDuration: 600
                    }
                };
                console.warn('Using fallback configuration');
                configLoaded = true;
                return config;
            }
        }

        // Authentication functions
        function initAuth() {
            // Check for stored auth token on page load
            const storedToken = localStorage.getItem('gf_auth_token');
            if (storedToken) {
                authToken = storedToken;
                // Validate token by fetching user profile
                fetchUserProfile();
            }
        }

        async function fetchUserProfile() {
            if (!authToken) return;

            try {
                const response = await fetch('http://localhost:3001/api/profile', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (response.ok) {
                    currentUser = await response.json();
                    isAuthenticated = true;
                    console.log('User authenticated:', currentUser.username);
                } else {
                    // Token invalid, clear it
                    logout();
                }
            } catch (error) {
                console.error('Error fetching user profile:', error);
                logout();
            }
        }

        function loginWithDiscord() {
            // Redirect to Discord OAuth
            window.location.href = 'http://localhost:3001/auth/discord';
        }

        function logout() {
            currentUser = null;
            authToken = null;
            isAuthenticated = false;
            localStorage.removeItem('gf_auth_token');
            gameState = GAME_STATES.START;
        }

        function handleAuthCallback() {
            // Check URL for auth success/failure
            const urlParams = new URLSearchParams(window.location.search);
            const authSuccess = urlParams.get('auth_success');

            if (authSuccess === 'true') {
                // Get token from URL or localStorage (set by backend)
                const token = localStorage.getItem('gf_auth_token');
                if (token) {
                    authToken = token;
                    fetchUserProfile().then(() => {
                        // Clear URL parameters
                        window.history.replaceState({}, document.title, window.location.pathname);
                        gameState = GAME_STATES.START;
                    });
                }
            } else if (urlParams.get('error')) {
                console.error('Authentication failed');
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        // Session analytics variables
        let sessionData = [];
        let sessionStats = {
            totalSessions: 0,
            totalScore: 0,
            averageScore: 0,
            bestScore: 0,
            totalPlayTime: 0,
            averageLevel: 0
        };

        // Session analytics functions
        async function loadSessionData() {
            sessionData = [];

            // Load from localStorage first
            const localSessions = JSON.parse(localStorage.getItem('galacticFrontier_sessions') || '[]');
            sessionData.push(...localSessions);

            // Try to load from backend if authenticated
            if (backendAvailable && authToken) {
                try {
                    // For now, we'll simulate session data since we don't have a full sessions API
                    // In production, this would fetch from /api/sessions/history
                    console.log('Loading session data from backend...');
                } catch (error) {
                    console.error('Failed to load backend sessions:', error);
                }
            }

            calculateSessionStats();
        }

        function calculateSessionStats() {
            if (sessionData.length === 0) {
                // Add some sample data for demonstration
                sessionData = [
                    {
                        sessionId: 'sample_1',
                        startTime: Date.now() - 3600000, // 1 hour ago
                        endTime: Date.now() - 3540000,  // 59 minutes ago
                        score: 1250,
                        level: 7,
                        playTime: 60,
                        accuracy: 85.5
                    },
                    {
                        sessionId: 'sample_2',
                        startTime: Date.now() - 7200000, // 2 hours ago
                        endTime: Date.now() - 7080000,  // ~2 hours ago
                        score: 890,
                        level: 5,
                        playTime: 120,
                        accuracy: 72.3
                    }
                ];
            }

            sessionStats.totalSessions = sessionData.length;
            sessionStats.totalScore = sessionData.reduce((sum, s) => sum + s.score, 0);
            sessionStats.averageScore = Math.round(sessionStats.totalScore / sessionStats.totalSessions);
            sessionStats.bestScore = Math.max(...sessionData.map(s => s.score));
            sessionStats.totalPlayTime = sessionData.reduce((sum, s) => sum + s.playTime, 0);
            sessionStats.averageLevel = Math.round(sessionData.reduce((sum, s) => sum + s.level, 0) / sessionStats.totalSessions * 10) / 10;
        }

        // Player ship
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            speed: 0,
            maxSpeed: 5, // Will be replaced with config value
            thrust: 0.1, // Will be replaced with config value
            size: 20, // Will be replaced with config value
            currentHealth: 100, // Will be replaced with config value
            afterburnerEnergy: 100, // Will be replaced with config value
            lastShot: 0
        };

        // Universe coordinates
        let universeX = 0;
        let universeY = 0;

        // Projectiles (player)
        const projectiles = [];
        let projectileSpeed = 7; // Will be replaced with config value
        let projectileLife = 100; // Will be replaced with config value
        let projectileCooldown = 10; // Will be replaced with config value

        // Enemy projectiles
        const enemyProjectiles = [];

        // Enemies
        const enemies = [];
        let spawnTimer = 0;
        let minSpawnInterval = 60; // Will be replaced with config value
        let maxSpawnInterval = 300; // Will be replaced with config value
        let nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
        let baseEnemyTypes = []; // Will be loaded from config

        // Explosions
        const explosions = [];

        // Particle effects system
        const particles = [];

        // Power-ups
        const powerUps = [];
        let healthPowerUpSpawnTimer = 0;
        let fanShotPowerUpSpawnTimer = 0;
        let nextHealthPowerUpSpawn = 0; // Will be initialized after config load
        let nextFanShotPowerUpSpawn = 0; // Will be initialized after config load

        // Active power-up effects
        let fanShotActive = false;
        let fanShotTimer = 0;

        // Authentication variables
        let currentUser = null;
        let authToken = null;
        let isAuthenticated = false;

        // Game states
        const GAME_STATES = {
            START: 'start',
            AUTH: 'auth',
            PROFILE: 'profile',
            SESSIONS: 'sessions',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };
        let gameState = GAME_STATES.START;

        // Scoreboard and levels
        let score = 0;
        let bulletsFired = 0;
        let bulletsHit = 0;
        let currentLevel = 1;
        let scoreToLevelUp = 500; // Will be replaced with config value
        let gameStartTime = 0;
        let gameEndTime = 0;
        let enemiesDefeated = 0;

        // Score multiplier system
        let scoreMultiplier = 1.0;
        let comboTimer = 0;
        let comboCount = 0;
        let lastKillTime = 0;

        // Score display enhancement
        let scoreChangeIndicator = null;
        let scoreChangeTimer = 0;
        let lastDisplayedScore = 0;

        // Fan-shot visual effect phase
        let fanShotVisualPhase = 0;

        // Audio system
        let audioContext = null;
        let audioEnabled = true;
        let masterVolume = 0.7;
        let musicVolume = 0.5;
        let sfxVolume = 0.8;
        let currentMusic = null;
        let audioBuffers = {}; // Cache for loaded audio files
        let activeAudio = []; // Track active audio instances

        // Apply config values to game variables
        function applyConfig() {
            if (!config) return;

            // Ship configuration
            ship.maxSpeed = config.ship.maxSpeed;
            ship.thrust = config.ship.thrust;
            ship.size = config.ship.size;
            ship.currentHealth = config.ship.maxHealth;
            ship.afterburnerEnergy = config.ship.afterburnerMax;

            // Projectile configuration
            projectileSpeed = config.projectiles.speed;
            projectileLife = config.projectiles.life;
            projectileCooldown = config.projectiles.cooldown;

            // Enemy configuration
            baseEnemyTypes = config.enemies;

            // Game configuration
            scoreToLevelUp = config.game.scoreToLevelUp;
            minSpawnInterval = config.game.minSpawnInterval;
            maxSpawnInterval = config.game.maxSpawnInterval;

            // Power-up configuration
            nextHealthPowerUpSpawn = Math.random() * (config.game.maxHealthSpawnInterval - config.game.minHealthSpawnInterval) + config.game.minHealthSpawnInterval;
            nextFanShotPowerUpSpawn = Math.random() * (config.game.maxFanShotSpawnInterval - config.game.minFanShotSpawnInterval) + config.game.minFanShotSpawnInterval;

            console.log('Configuration applied to game variables');
        }

        // Control state variables
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let thrustPressed = false;
        let afterburnerPressed = false;
        let leftMousePressed = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            // Ensure mouse coordinates stay within canvas bounds
            mouseX = Math.max(0, Math.min(mouseX, canvas.width));
            mouseY = Math.max(0, Math.min(mouseY, canvas.height));
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 0) { // Left mouse button
                e.preventDefault(); // Prevent context menu
                leftMousePressed = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 0) { // Left mouse button
                leftMousePressed = false;
            }
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        document.addEventListener('keydown', (e) => {
            if (gameState === GAME_STATES.START) {
                if (e.key === ' ' || e.key === 'Enter') {
                    // Check if user is authenticated, if not go to auth screen
                    if (isAuthenticated) {
                        gameState = GAME_STATES.PROFILE;
                    } else {
                        gameState = GAME_STATES.AUTH;
                    }
                } else if (e.key === 'a' || e.key === 'A') {
                    // Access session analytics
                    loadSessionData();
                    gameState = GAME_STATES.SESSIONS;
                }
            } else if (gameState === GAME_STATES.AUTH) {
                if (e.key === ' ' || e.key === 'Enter') {
                    loginWithDiscord();
                } else if (e.key === 'Escape') {
                    // Skip authentication and start game directly
                    startGame();
                }
            } else if (gameState === GAME_STATES.PROFILE) {
                if (e.key === ' ' || e.key === 'Enter') {
                    startGame();
                } else if (e.key === 'l' || e.key === 'L') {
                    logout();
                    gameState = GAME_STATES.START;
                } else if (e.key === 's' || e.key === 'S') {
                    loadSessionData();
                    gameState = GAME_STATES.SESSIONS;
                }
            } else if (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.PAUSED) {
                if (e.key === 'p' || e.key === 'P') {
                    togglePause();
                } else if (gameState === GAME_STATES.PLAYING) {
                    if (e.key === 'w' || e.key === 'W') thrustPressed = true;
                    if (e.key === ' ') {
                        e.preventDefault(); // Prevent page scroll
                        afterburnerPressed = true;
                    }
                }
            } else if (gameState === GAME_STATES.GAME_OVER) {
                if (e.key === 'r' || e.key === 'R') {
                    gameState = GAME_STATES.START;
                }
            } else if (gameState === GAME_STATES.SESSIONS) {
                if (e.key === 'Escape') {
                    gameState = GAME_STATES.START;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameState === GAME_STATES.PLAYING) {
                if (e.key === 'w' || e.key === 'W') thrustPressed = false;
                if (e.key === ' ') afterburnerPressed = false;
            }
        });

        // Stars
        const stars = [];
        for (let i = 0; i < 500; i++) {
            stars.push({
                universeX: (Math.random() - 0.5) * 8000,
                universeY: (Math.random() - 0.5) * 8000,
                size: Math.random() * 2 + 1
            });
        }

        async function startGame() {
            gameState = GAME_STATES.PLAYING;
            gameStartTime = Date.now();

            // Check backend availability and initialize session
            await checkBackendAvailability();
            await initializeGameSession();

            resetGame();
            playBackgroundMusic();
        }

        function resetGame() {
            ship.currentHealth = config ? config.ship.maxHealth : 100;
            ship.afterburnerEnergy = config ? config.ship.afterburnerMax : 100;
            ship.speed = 0;
            ship.angle = 0;
            universeX = 0;
            universeY = 0;
            score = 0;
            bulletsFired = 0;
            bulletsHit = 0;
            gameEndTime = 0;
            enemiesDefeated = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            enemies.length = 0;
            explosions.length = 0;
            particles.length = 0;
            powerUps.length = 0;
            spawnTimer = 0;
            nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
            healthPowerUpSpawnTimer = 0;
            fanShotPowerUpSpawnTimer = 0;
            nextHealthPowerUpSpawn = Math.random() * (config.game.maxHealthSpawnInterval - config.game.minHealthSpawnInterval) + config.game.minHealthSpawnInterval;
            nextFanShotPowerUpSpawn = Math.random() * (config.game.maxFanShotSpawnInterval - config.game.minFanShotSpawnInterval) + config.game.minFanShotSpawnInterval;
            fanShotActive = false;
            fanShotTimer = 0;
            currentLevel = 1;
            gameState = GAME_STATES.PLAYING;
        }

        async function endGame() {
            // Capture final play time when game ends
            gameEndTime = Date.now();

            // Stop background music
            stopBackgroundMusic();

            // Calculate final statistics
            const playTime = Math.floor((gameEndTime - gameStartTime) / 1000);
            const accuracy = bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100) : 0;

            // End session with backend
            await endGameSession(score, currentLevel, playTime, accuracy);

            // Save high score before ending game
            if (validateScoreData(score)) {
                await saveHighScore(score, currentLevel, playTime, accuracy);
                await initializeTopScores(); // Refresh the top scores display
            }
            gameState = GAME_STATES.GAME_OVER;
        }

        function togglePause() {
            if (gameState === GAME_STATES.PLAYING) {
                gameState = GAME_STATES.PAUSED;
            } else if (gameState === GAME_STATES.PAUSED) {
                gameState = GAME_STATES.PLAYING;
            }
        }

        function drawStartScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC FRONTIER', canvas.width / 2, canvas.height / 2 - 100);

            // Instructions
            ctx.font = '20px Arial';
            ctx.fillText('Controls:', canvas.width / 2, canvas.height / 2 - 40);
            ctx.font = '16px Arial';
            ctx.fillText('Mouse Movement - Rotate Ship', canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText('W - Thrust Forward', canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText('Spacebar - Afterburner (Limited Energy)', canvas.width / 2, canvas.height / 2 + 30);
            ctx.fillText('Left Mouse Button - Shoot', canvas.width / 2, canvas.height / 2 + 50);
            ctx.fillText('P - Pause/Resume', canvas.width / 2, canvas.height / 2 + 70);

            // Start prompt
            ctx.font = '24px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('Press SPACEBAR or ENTER to Start', canvas.width / 2, canvas.height / 2 + 100);

            // Analytics option
            ctx.font = '16px Arial';
            ctx.fillStyle = 'cyan';
            ctx.fillText('Press A for Session Analytics', canvas.width / 2, canvas.height / 2 + 130);

            // Version/Config info
            ctx.font = '12px Arial';
            ctx.fillStyle = 'gray';
            ctx.textAlign = 'right';
            ctx.fillText('Configuration Loaded', canvas.width - 10, canvas.height - 20);
        }

        function drawAuthScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC FRONTIER', canvas.width / 2, canvas.height / 2 - 100);

            // Auth prompt
            ctx.font = '24px Arial';
            ctx.fillStyle = '#7289da';
            ctx.fillText('Login with Discord', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '16px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText('Submit scores to global leaderboards', canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText('Track your progress across sessions', canvas.width / 2, canvas.height / 2 + 30);

            // Login button visual
            ctx.fillStyle = '#7289da';
            ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 + 60, 200, 40);
            ctx.fillStyle = 'white';
            ctx.font = '18px Arial';
            ctx.fillText('Login with Discord', canvas.width / 2, canvas.height / 2 + 85);

            // Skip option
            ctx.font = '14px Arial';
            ctx.fillStyle = 'gray';
            ctx.fillText('Press ESC to play without login', canvas.width / 2, canvas.height / 2 + 120);
        }

        function drawProfileScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC FRONTIER', canvas.width / 2, canvas.height / 2 - 100);

            // User info
            if (currentUser) {
                ctx.font = '24px Arial';
                ctx.fillStyle = '#00ff00';
                ctx.fillText(`Welcome, ${currentUser.username}!`, canvas.width / 2, canvas.height / 2 - 20);

                ctx.font = '16px Arial';
                ctx.fillStyle = 'white';
                ctx.fillText(`Level: ${currentUser.level || 1}`, canvas.width / 2, canvas.height / 2 + 10);
                ctx.fillText(`Total Score: ${currentUser.total_score || 0}`, canvas.width / 2, canvas.height / 2 + 30);
            }

            // Continue prompt
            ctx.font = '20px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('Press SPACEBAR or ENTER to Start', canvas.width / 2, canvas.height / 2 + 80);

            // Logout option
            ctx.font = '14px Arial';
            ctx.fillStyle = 'gray';
            ctx.fillText('Press L to logout', canvas.width / 2, canvas.height / 2 + 110);
        }

        function drawSessionsScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SESSION ANALYTICS', canvas.width / 2, 50);

            // Stats display
            ctx.font = '18px Arial';
            ctx.textAlign = 'left';
            let yPos = 100;

            ctx.fillText(`Total Sessions: ${sessionStats.totalSessions}`, 50, yPos);
            yPos += 30;
            ctx.fillText(`Best Score: ${sessionStats.bestScore.toLocaleString()}`, 50, yPos);
            yPos += 30;
            ctx.fillText(`Average Score: ${sessionStats.averageScore.toLocaleString()}`, 50, yPos);
            yPos += 30;
            ctx.fillText(`Average Level: ${sessionStats.averageLevel}`, 50, yPos);
            yPos += 30;
            ctx.fillText(`Total Play Time: ${Math.floor(sessionStats.totalPlayTime / 60)}m ${sessionStats.totalPlayTime % 60}s`, 50, yPos);

            // Recent sessions
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Recent Sessions', canvas.width / 2, yPos + 50);

            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            yPos += 80;

            // Show last 3 sessions
            const recentSessions = sessionData.slice(-3).reverse();
            recentSessions.forEach((session, index) => {
                const sessionTime = new Date(session.startTime).toLocaleString();
                ctx.fillText(`${index + 1}. ${sessionTime} - Score: ${session.score.toLocaleString()} - Level: ${session.level}`, 50, yPos);
                yPos += 25;
            });

            // Navigation
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('Press ESC to return to menu', canvas.width / 2, canvas.height - 30);
        }

        function drawPauseScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pause text
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 50);

            // Instructions
            ctx.font = '24px Arial';
            ctx.fillText('Press P to Resume', canvas.width / 2, canvas.height / 2 + 20);

            // Game stats (in arcade style layout)
            ctx.font = '20px Arial';
            ctx.fillText(`LEVEL ${currentLevel}     SCORE ${score}/${scoreToLevelUp}`, canvas.width / 2, canvas.height / 2 + 70);

            // Health and Afterburner bars
            const barWidth = 120;
            const barHeight = 14;
            const barY = canvas.height / 2 + 90;

            // Health bar (left)
            const healthPercent = ship.currentHealth / config.ship.maxHealth;
            const healthBarX = canvas.width / 2 - barWidth - 20;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(healthBarX, barY, barWidth, barHeight);

            let healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
            ctx.fillStyle = healthColor;
            ctx.fillRect(healthBarX, barY, barWidth * healthPercent, barHeight);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(healthBarX, barY, barWidth, barHeight);

            // Afterburner bar (right)
            const energyPercent = ship.afterburnerEnergy / config.ship.afterburnerMax;
            const energyBarX = canvas.width / 2 + 20;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(energyBarX, barY, barWidth, barHeight);

            let energyColor = energyPercent > 0.6 ? '#ffffff' : energyPercent > 0.3 ? '#00ffff' : '#0000ff';
            ctx.fillStyle = energyColor;
            ctx.fillRect(energyBarX, barY, barWidth * energyPercent, barHeight);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(energyBarX, barY, barWidth, barHeight);

            // Stats at bottom
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText(`SHOTS: ${bulletsFired}     ACCURACY: ${bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100).toFixed(1) : 0}%`, canvas.width / 2, canvas.height / 2 + 130);
        }

        function spawnEnemy() {
            const rand = Math.random();
            let type;
            if (rand < 0.5) type = baseEnemyTypes[0];
            else if (rand < 0.8) type = baseEnemyTypes[1];
            else type = baseEnemyTypes[2];

            const levelMultiplier = Math.pow(1.1, currentLevel - 1); // 10% increase per level

            // Level-based scaling for various attributes
            const speedMultiplier = Math.pow(1.05, currentLevel - 1); // 5% speed increase per level
            const healthMultiplier = Math.pow(1.15, currentLevel - 1); // 15% health increase per level (for collision damage)

            const angle = Math.random() * Math.PI * 2;
            const distance = 500;
            enemies.push({
                universeX: universeX + Math.cos(angle) * distance,
                universeY: universeY + Math.sin(angle) * distance,
                angle: 0,
                speed: type.speed * speedMultiplier, // Scaled speed
                size: type.size,
                points: type.points,
                type: type.type,
                shootInterval: type.shootInterval,
                shootTimer: Math.random() * type.shootInterval,
                projectileDamage: type.projectileDamage * levelMultiplier, // Scaled projectile damage
                collisionDamage: type.collisionDamage * healthMultiplier, // Scaled collision damage
                level: currentLevel // Track enemy level for behavior modifications
            });
        }

        function updateShip() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            ship.angle = Math.atan2(mouseY - ship.y, mouseX - ship.x);

            // Handle thrust (W key)
            if (thrustPressed) {
                ship.speed = Math.min(ship.speed + ship.thrust, ship.maxSpeed);
                // Play thruster sound periodically (not every frame)
                if (Math.random() < 0.3) playThrusterSound();
            } else {
                ship.speed = Math.max(ship.speed - ship.thrust / 2, 0);
            }

            // Handle afterburner (spacebar) - only if energy available
            let effectiveSpeed = ship.speed;
            if (afterburnerPressed && ship.afterburnerEnergy > 0) {
                effectiveSpeed *= config.ship.afterburnerBoost;
                ship.afterburnerEnergy = Math.max(0, ship.afterburnerEnergy - config.ship.afterburnerDepleteRate);
                // Play afterburner sound periodically (not every frame)
                if (Math.random() < 0.4) playAfterburnerSound();
            } else if (ship.afterburnerEnergy < config.ship.afterburnerMax) {
                ship.afterburnerEnergy = Math.min(config.ship.afterburnerMax, ship.afterburnerEnergy + config.ship.afterburnerRegenRate);
            }

            universeX += Math.cos(ship.angle) * effectiveSpeed;
            universeY += Math.sin(ship.angle) * effectiveSpeed;

            // Handle shooting (left mouse button)
                if (leftMousePressed && ship.lastShot <= 0) {
                    if (fanShotActive) {
                        // Fan-shot: fire 10 projectiles in a spread pattern
                        const spreadAngle = config.projectiles.fanShotAngle; // 0.1047 radians (6 degrees)
                        const halfSpread = (config.projectiles.fanShotCount - 1) * spreadAngle / 2;
                        for (let i = 0; i < config.projectiles.fanShotCount; i++) {
                            const angle = ship.angle - halfSpread + (i * spreadAngle);
                            projectiles.push({
                                universeX: universeX,
                                universeY: universeY,
                                angle: angle,
                                life: projectileLife
                            });
                        }
                        bulletsFired += config.projectiles.fanShotCount;
                    } else {
                        // Normal shot: single projectile
                        projectiles.push({
                            universeX: universeX,
                            universeY: universeY,
                            angle: ship.angle,
                            life: projectileLife
                        });
                        bulletsFired++;
                    }
                    ship.lastShot = projectileCooldown;
                    playShootSound();
                }
            if (ship.lastShot > 0) ship.lastShot--;
        }

        // --- Basic Touch Support (maps to existing inputs) ---
        // Prevent default gestures like scroll/zoom over the canvas
        canvas.style.touchAction = 'none';

        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isTouch) {
            const getTouchPos = (t) => {
                const rect = canvas.getBoundingClientRect();
                const x = t.clientX - rect.left;
                const y = t.clientY - rect.top;
                return {
                    x: Math.max(0, Math.min(x, canvas.width)),
                    y: Math.max(0, Math.min(y, canvas.height))
                };
            };

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const t = e.touches[0];
                if (!t) return;
                const { x, y } = getTouchPos(t);
                mouseX = x;
                mouseY = y;
                // Shooting on initial touch
                leftMousePressed = true;
                // Thrust if first touch on left half of canvas
                thrustPressed = x < canvas.width / 2;
                // Afterburner when 2+ fingers
                afterburnerPressed = e.touches.length >= 2;
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const t = e.touches[0];
                if (!t) return;
                const { x, y } = getTouchPos(t);
                mouseX = x;
                mouseY = y;
                thrustPressed = x < canvas.width / 2;
                afterburnerPressed = e.touches.length >= 2;
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (e.touches.length === 0) {
                    leftMousePressed = false;
                    thrustPressed = false;
                    afterburnerPressed = false;
                } else {
                    const t = e.touches[0];
                    if (t) {
                        const { x } = getTouchPos(t);
                        thrustPressed = x < canvas.width / 2;
                    }
                    afterburnerPressed = e.touches.length >= 2;
                }
            }, { passive: false });
        }

        function updateProjectiles() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            // Player projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                // Create trail particles for player projectiles
                if (Math.random() < 0.3) { // 30% chance to create trail particle
                    createTrailParticles(p.universeX, p.universeY, '#ffffff', 1);
                }

                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(p.universeX - e.universeX, p.universeY - e.universeY);
                    if (dist < e.size) {
                        // Create explosion particles instead of old explosion system
                        const explosionColor = e.type === 'small' ? '#ff6600' : e.type === 'medium' ? '#ffaa00' : '#ff4444';
                        createExplosionParticles(e.universeX, e.universeY, explosionColor, 12);

                        addScore(e.points, e.type);
                        bulletsHit++;
                        enemiesDefeated++;
                        enemies.splice(j, 1);
                        projectiles.splice(i, 1);
                        playExplosionSound();
                        // Check for level-up
                        if (score >= scoreToLevelUp * currentLevel) {
                            currentLevel++;
                            enemies.length = 0; // Clear enemies
                            enemyProjectiles.length = 0; // Clear enemy projectiles
                            particles.length = 0; // Clear particles on level up
                            // Reset combo on level up
                            comboCount = 0;
                            scoreMultiplier = 1.0;
                            comboTimer = 0;
                        }
                        break;
                    }
                }
            }

            // Enemy projectiles
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                const dist = Math.hypot(p.universeX - universeX, p.universeY - universeY);
                if (dist < ship.size) {
                    ship.currentHealth = Math.max(0, ship.currentHealth - p.damage);
                    enemyProjectiles.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateEnemies() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            spawnTimer++;
            if (spawnTimer >= nextSpawn) {
                spawnEnemy();
                spawnTimer = 0;
                // Level-based spawn rate adjustment - enemies spawn more frequently at higher levels
                const spawnRateMultiplier = Math.max(0.3, 1 - (currentLevel - 1) * 0.1); // Minimum 30% of base rate
                const adjustedMinInterval = minSpawnInterval * spawnRateMultiplier;
                const adjustedMaxInterval = maxSpawnInterval * spawnRateMultiplier;
                nextSpawn = Math.random() * (adjustedMaxInterval - adjustedMinInterval) + adjustedMinInterval;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                // Calculate target angle toward player
                const dx = universeX - e.universeX;
                const dy = universeY - e.universeY;
                const targetAngle = Math.atan2(dy, dx);

                // Smooth turning mechanics - gradual rotation toward target
                let angleDiff = targetAngle - e.angle;
                // Normalize angle difference to [-, ]
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                // Turn rate and behavior based on enemy type
                let turnRate, pursuitMultiplier, shootAccuracy;
                if (e.type === 'small') {
                    turnRate = 0.15; // Fast turning - aggressive
                    pursuitMultiplier = 1.2; // More aggressive pursuit
                    shootAccuracy = 0.9; // Good accuracy
                } else if (e.type === 'medium') {
                    turnRate = 0.1; // Medium turning - balanced
                    pursuitMultiplier = 1.0; // Normal pursuit
                    shootAccuracy = 0.95; // Better accuracy
                } else { // large
                    turnRate = 0.05; // Slow turning - methodical
                    pursuitMultiplier = 0.8; // Less aggressive pursuit
                    shootAccuracy = 1.0; // Perfect accuracy
                }

                // Apply pursuit multiplier to turn rate for behavioral variation
                turnRate *= pursuitMultiplier;
                e.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate);

                // Basic collision avoidance - steer away from nearby enemies
                let avoidX = 0;
                let avoidY = 0;
                for (let j = 0; j < enemies.length; j++) {
                    if (i === j) continue;
                    const other = enemies[j];
                    const dist = Math.hypot(other.universeX - e.universeX, other.universeY - e.universeY);
                    if (dist < 30 && dist > 0) { // Avoid if too close
                        const avoidAngle = Math.atan2(e.universeY - other.universeY, e.universeX - other.universeX);
                        avoidX += Math.cos(avoidAngle) * (30 - dist) * 0.1;
                        avoidY += Math.sin(avoidAngle) * (30 - dist) * 0.1;
                    }
                }

                // Apply movement with collision avoidance
                const moveX = Math.cos(e.angle) + avoidX;
                const moveY = Math.sin(e.angle) + avoidY;
                const moveMagnitude = Math.hypot(moveX, moveY);

                if (moveMagnitude > 0) {
                    e.universeX += (moveX / moveMagnitude) * e.speed;
                    e.universeY += (moveY / moveMagnitude) * e.speed;
                } else {
                    // Fallback if no movement calculated
                    e.universeX += Math.cos(e.angle) * e.speed;
                    e.universeY += Math.sin(e.angle) * e.speed;
                }

                e.shootTimer++;
                if (e.shootTimer >= e.shootInterval) {
                    // Calculate shooting direction toward player with accuracy variation
                    const shootDx = universeX - e.universeX;
                    const shootDy = universeY - e.universeY;
                    const baseShootAngle = Math.atan2(shootDy, shootDx);

                    // Apply accuracy variation based on enemy type
                    let accuracyVariation;
                    if (e.type === 'small') {
                        accuracyVariation = (Math.random() - 0.5) * 0.3; // 0.15 radians variation
                    } else if (e.type === 'medium') {
                        accuracyVariation = (Math.random() - 0.5) * 0.2; // 0.1 radians variation
                    } else { // large
                        accuracyVariation = 0; // Perfect accuracy
                    }

                    const shootAngle = baseShootAngle + accuracyVariation;

                    enemyProjectiles.push({
                        universeX: e.universeX,
                        universeY: e.universeY,
                        angle: shootAngle, // Shoot toward player with accuracy variation
                        life: projectileLife,
                        damage: e.projectileDamage
                    });
                    e.shootTimer = 0;
                    playEnemyShootSound();
                }

                const dist = Math.hypot(e.universeX - universeX, e.universeY - universeY);
                if (dist < e.size + ship.size) {
                    // Create explosion particles for enemy collision
                    createExplosionParticles(e.universeX, e.universeY, '#ff4444', 8);
                    ship.currentHealth = Math.max(0, ship.currentHealth - e.collisionDamage);
                    enemies.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateExplosions() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.radius += 2;
                exp.life--;
                if (exp.life <= 0) explosions.splice(i, 1);
            }
        }

        function spawnPowerUp(type) {
            if (!configLoaded) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 300 + 200; // Spawn between 200-500 units from player
            powerUps.push({
                universeX: universeX + Math.cos(angle) * distance,
                universeY: universeY + Math.sin(angle) * distance,
                type: type,
                size: 8,
                life: 600 // Power-ups disappear after 600 frames
            });
        }

        // Particle effects system
        function createExplosionParticles(x, y, color = '#ffff00', count = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    universeX: x,
                    universeY: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    size: 2 + Math.random() * 2,
                    color: color,
                    type: 'explosion'
                });
            }
        }

        function createTrailParticles(x, y, color = '#ffffff', count = 2) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    universeX: x + (Math.random() - 0.5) * 4,
                    universeY: y + (Math.random() - 0.5) * 4,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    life: 15 + Math.random() * 10,
                    maxLife: 25,
                    size: 1 + Math.random(),
                    color: color,
                    type: 'trail'
                });
            }
        }

        function updateParticles() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.universeX += p.vx;
                p.universeY += p.vy;
                p.life--;

                // Apply gravity to explosion particles
                if (p.type === 'explosion') {
                    p.vy += 0.1; // Slight gravity
                    p.vx *= 0.98; // Air resistance
                    p.vy *= 0.98;
                }

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Audio system functions
        function initAudio() {
            try {
                // Create audio context
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    audioContext = new AudioContext();
                    console.log('Audio system initialized');
                } else {
                    console.warn('Web Audio API not supported, using fallback');
                    audioEnabled = false;
                }
            } catch (error) {
                console.warn('Audio initialization failed:', error);
                audioEnabled = false;
            }
        }

        async function loadAudioBuffer(url) {
            if (!audioEnabled || !audioContext) return null;

            try {
                if (audioBuffers[url]) {
                    return audioBuffers[url];
                }

                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                audioBuffers[url] = audioBuffer;
                return audioBuffer;
            } catch (error) {
                console.warn('Failed to load audio:', url, error);
                return null;
            }
        }

        function playSound(buffer, volume = 1.0, loop = false) {
            if (!audioEnabled || !audioContext || !buffer) return null;

            try {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();

                source.buffer = buffer;
                source.loop = loop;

                // Set volume
                gainNode.gain.value = volume * masterVolume * (loop ? musicVolume : sfxVolume);

                source.connect(gainNode);
                gainNode.connect(audioContext.destination);

                source.start();

                // Track active audio for cleanup
                const audioInstance = { source, gainNode, loop };
                activeAudio.push(audioInstance);

                // Remove from tracking when done (for non-looping sounds)
                if (!loop) {
                    source.onended = () => {
                        const index = activeAudio.indexOf(audioInstance);
                        if (index > -1) activeAudio.splice(index, 1);
                    };
                }

                return audioInstance;
            } catch (error) {
                console.warn('Failed to play sound:', error);
                return null;
            }
        }

        function stopSound(audioInstance) {
            if (!audioInstance) return;

            try {
                audioInstance.source.stop();
            } catch (error) {
                // Sound might already be stopped
            }

            const index = activeAudio.indexOf(audioInstance);
            if (index > -1) activeAudio.splice(index, 1);
        }

        function setMasterVolume(volume) {
            masterVolume = Math.max(0, Math.min(1, volume));
            updateAudioVolumes();
        }

        function setMusicVolume(volume) {
            musicVolume = Math.max(0, Math.min(1, volume));
            updateAudioVolumes();
        }

        function setSFXVolume(volume) {
            sfxVolume = Math.max(0, Math.min(1, volume));
            updateAudioVolumes();
        }

        function updateAudioVolumes() {
            activeAudio.forEach(audioInstance => {
                const targetVolume = audioInstance.loop ? musicVolume : sfxVolume;
                audioInstance.gainNode.gain.value = targetVolume * masterVolume;
            });
        }

        function stopAllAudio() {
            activeAudio.forEach(audioInstance => {
                try {
                    audioInstance.source.stop();
                } catch (error) {
                    // Ignore errors for already stopped sounds
                }
            });
            activeAudio.length = 0;
            currentMusic = null;
        }

        // Fallback audio system using HTML5 Audio for browsers without Web Audio API
        function playSoundFallback(url, volume = 1.0, loop = false) {
            if (!audioEnabled) return null;

            try {
                const audio = new Audio(url);
                audio.volume = volume * masterVolume * (loop ? musicVolume : sfxVolume);
                audio.loop = loop;

                audio.play().catch(error => {
                    console.warn('Fallback audio playback failed:', error);
                });

                if (!loop) {
                    audio.onended = () => {
                        // Cleanup handled automatically
                    };
                }

                return audio;
            } catch (error) {
                console.warn('Fallback audio failed:', error);
                return null;
            }
        }

        function updateScoreMultiplier() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            comboTimer--;
            if (comboTimer <= 0) {
                comboCount = 0;
                scoreMultiplier = 1.0;
            }

            // Update score change indicator animation
            if (scoreChangeIndicator) {
                scoreChangeIndicator.life--;
                scoreChangeIndicator.alpha = scoreChangeIndicator.life / 60;
                scoreChangeIndicator.y -= 0.5; // Float upward

                if (scoreChangeIndicator.life <= 0) {
                    scoreChangeIndicator = null;
                }
            }
        }

        function addScore(points, enemyType) {
            // Anti-cheat: validate reasonable score values
            if (points < 0 || points > 1000) {
                console.warn('Invalid score value detected:', points);
                return;
            }

            // Combo system: consecutive kills within 1 second increase multiplier
            const currentTime = Date.now();
            const timeSinceLastKill = currentTime - lastKillTime;

            if (timeSinceLastKill < 1000) { // 1 second window for combo
                comboCount++;
                scoreMultiplier = Math.min(5.0, 1.0 + (comboCount * 0.2)); // Max 5x multiplier
                comboTimer = 120; // 2 seconds to maintain combo
            } else {
                comboCount = 1;
                scoreMultiplier = 1.0;
                comboTimer = 120;
            }
            lastKillTime = currentTime;

            const multipliedPoints = Math.floor(points * scoreMultiplier);
            const oldScore = score;
            score += multipliedPoints;

            // Create score change indicator for animations
            scoreChangeIndicator = {
                points: multipliedPoints,
                basePoints: points,
                multiplier: scoreMultiplier,
                x: canvas.width / 2,
                y: 35,
                alpha: 1.0,
                life: 60 // 1 second display
            };
            scoreChangeTimer = 60;

            console.log(`Enemy destroyed: ${enemyType} (${points} pts  ${scoreMultiplier.toFixed(1)} = ${multipliedPoints} pts)`);

            // Check for milestone achievements
            if (score >= 1000 && oldScore < 1000) {
                console.log(' Milestone: 1000 points reached!');
            } else if (score >= 500 && oldScore < 500) {
                console.log(' Milestone: 500 points reached!');
            }
        }

        function updatePowerUps() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            // Update power-up spawn timers
            healthPowerUpSpawnTimer++;
            if (healthPowerUpSpawnTimer >= nextHealthPowerUpSpawn) {
                spawnPowerUp('health');
                healthPowerUpSpawnTimer = 0;
                nextHealthPowerUpSpawn = Math.random() * (config.game.maxHealthSpawnInterval - config.game.minHealthSpawnInterval) + config.game.minHealthSpawnInterval;
            }

            fanShotPowerUpSpawnTimer++;
            if (fanShotPowerUpSpawnTimer >= nextFanShotPowerUpSpawn) {
                spawnPowerUp('fanShot');
                fanShotPowerUpSpawnTimer = 0;
                nextFanShotPowerUpSpawn = Math.random() * (config.game.maxFanShotSpawnInterval - config.game.minFanShotSpawnInterval) + config.game.minFanShotSpawnInterval;
            }

            // Update active power-up effects
            if (fanShotActive) {
                fanShotTimer--;
                if (fanShotTimer <= 0) {
                    fanShotActive = false;
                }
            }

            // Update power-up lifetimes and check collisions
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                p.life--;

                // Check collision with ship
                const dist = Math.hypot(p.universeX - universeX, p.universeY - universeY);
                if (dist < p.size + ship.size) {
                    // Power-up collected
                    if (p.type === 'health') {
                        ship.currentHealth = Math.min(config.ship.maxHealth, ship.currentHealth + config.game.healthPowerUpValue);
                        console.log('Health power-up collected! +10 HP');
                        playPowerUpSound();
                    } else if (p.type === 'fanShot') {
                        // Prevent stacking - reset timer if already active
                        fanShotActive = true;
                        fanShotTimer = config.game.fanShotDuration;
                        console.log('Fan-shot power-up collected! Multi-shot active for 10 seconds');
                        playPowerUpSound();
                    }
                    powerUps.splice(i, 1);
                    continue;
                }

                // Remove expired power-ups
                if (p.life <= 0) {
                    powerUps.splice(i, 1);
                }
            }
        }

        function draw() {
            if (gameState === GAME_STATES.START) {
                drawStartScreen();
                return;
            }

            if (gameState === GAME_STATES.AUTH) {
                drawAuthScreen();
                return;
            }

            if (gameState === GAME_STATES.PROFILE) {
                drawProfileScreen();
                return;
            }

            if (gameState === GAME_STATES.SESSIONS) {
                drawSessionsScreen();
                return;
            }

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw game world
            drawGame();

            // Draw pause overlay if paused
            if (gameState === GAME_STATES.PAUSED) {
                drawPauseScreen();
            }
        }

        function drawGame() {

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw projectiles
            ctx.fillStyle = 'white';
            projectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemy projectiles
            ctx.fillStyle = 'orange';
            enemyProjectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemies
            enemies.forEach(e => {
                const screenX = e.universeX - universeX + canvas.width / 2;
                const screenY = e.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(e.angle);
                    ctx.beginPath();
                    if (e.type === 'small') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(-e.size / 2, e.size / 2);
                        ctx.lineTo(-e.size / 2, -e.size / 2);
                    } else if (e.type === 'medium') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(0, e.size / 2);
                        ctx.lineTo(-e.size, 0);
                        ctx.lineTo(0, -e.size / 2);
                    } else {
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            const x = e.size * Math.cos(angle);
                            const y = e.size * Math.sin(angle);
                            ctx[i === 0 ? 'moveTo' : 'lineTo'](x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Draw power-ups
            powerUps.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.save();
                    ctx.translate(screenX, screenY);

                    // Draw power-up based on type
                    if (p.type === 'health') {
                        ctx.fillStyle = '#00ff00'; // Green for health
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        // Draw cross
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-4, 0);
                        ctx.lineTo(4, 0);
                        ctx.moveTo(0, -4);
                        ctx.lineTo(0, 4);
                        ctx.stroke();
                    } else if (p.type === 'fanShot') {
                        ctx.fillStyle = '#ff00ff'; // Magenta for fan-shot
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        // Draw fan pattern
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2) / 5;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(angle) * p.size * 1.5, Math.sin(angle) * p.size * 1.5);
                            ctx.stroke();
                        }
                    }

                    ctx.restore();
                }
            });

            // Draw explosions (legacy system for compatibility)
            ctx.strokeStyle = 'yellow';
            explosions.forEach(exp => {
                const screenX = exp.universeX - universeX + canvas.width / 2;
                const screenY = exp.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, exp.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw particles
            particles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    const alpha = p.life / p.maxLife;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Draw spaceship
            if (gameState === GAME_STATES.PLAYING) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);
                ctx.beginPath();
                ctx.moveTo(ship.size, 0);
                ctx.lineTo(ship.size * 0.3, ship.size * 0.5);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.5);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.3, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, -ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, -ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.restore();

                // Fan-shot active visual effect: pulsing ring + rotating orbs
                if (fanShotActive) {
                    ctx.save();
                    ctx.translate(ship.x, ship.y);

                    // Calculate time remaining ratio (0-1, where 1 is full time)
                    const timeRatio = fanShotTimer / config.game.fanShotDuration;

                    // Ring fades and shrinks dramatically as time runs out
                    const pulse = (Math.sin(fanShotVisualPhase * (0.5 + 0.5 * timeRatio)) + 1) * 0.5; // Slower pulsing as time runs out
                    const baseRingRadius = ship.size * 1.4;
                    const maxRingSize = ship.size * 0.8; // Maximum additional size
                    const ringRadius = baseRingRadius + (maxRingSize * pulse * timeRatio); // Scales down dramatically as time runs out

                    // Color shifts from bright magenta to faded as time runs out
                    const alpha = 0.3 + (0.4 * timeRatio); // More transparent as time runs out
                    const saturation = timeRatio * 255; // Less saturated as time runs out
                    ctx.strokeStyle = `rgba(${255}, ${0}, ${saturation | 0}, ${alpha})`;
                    ctx.lineWidth = 1 + timeRatio; // Thinner as time runs out
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Rotating orbs - fewer orbs as time runs out
                    const maxOrbCount = 6;
                    const orbCount = Math.ceil(maxOrbCount * timeRatio);
                    const orbitRadius = ship.size * (1.7 - 0.2 * (1 - timeRatio)); // Closer to ship as time runs out

                    for (let i = 0; i < orbCount; i++) {
                        const a = fanShotVisualPhase + (i * (Math.PI * 2 / orbCount));
                        const ox = Math.cos(a) * orbitRadius;
                        const oy = Math.sin(a) * orbitRadius;
                        const orbAlpha = 0.4 + (0.4 * timeRatio); // Orbs fade as time runs out
                        const orbSaturation = timeRatio * 255;
                        ctx.fillStyle = `rgba(${255}, ${0}, ${orbSaturation | 0}, ${orbAlpha})`;
                        ctx.beginPath();
                        ctx.arc(ox, oy, (2 + 1.5 * pulse) * timeRatio, 0, Math.PI * 2); // Smaller orbs as time runs out
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            // Draw scoreboard and UI (only during gameplay)
            if (gameState === GAME_STATES.PLAYING) {
                // Top HUD - Score (top-left), Level (top-center)
                // Score display (top-left)
                ctx.fillStyle = 'white';
                ctx.font = '18px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`SCORE: ${score.toLocaleString()}`, 15, 30);

                // Level indicator (top-center)
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`LEVEL ${currentLevel}`, canvas.width / 2, 30);

                // Draw score change indicator
                if (scoreChangeIndicator) {
                    ctx.save();
                    ctx.globalAlpha = scoreChangeIndicator.alpha;
                    ctx.fillStyle = scoreChangeIndicator.multiplier > 1 ? '#00ff00' : 'white';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    const indicatorText = scoreChangeIndicator.multiplier > 1
                        ? `+${scoreChangeIndicator.points} (${scoreChangeIndicator.multiplier.toFixed(1)}x)`
                        : `+${scoreChangeIndicator.points}`;
                    ctx.fillText(indicatorText, scoreChangeIndicator.x, scoreChangeIndicator.y);
                    ctx.restore();
                }

                // Draw combo indicator
                if (comboCount > 1 && comboTimer > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${comboCount}x COMBO!`, canvas.width / 2, 55);
                }

                // Bottom HUD bars - Health (bottom-left), Afterburner (bottom-center), Hit % (bottom-right)
                const barWidth = 140;
                const barHeight = 18;
                const bottomBarY = canvas.height - 35;

                // Health bar (bottom-left)
                const healthPercent = ship.currentHealth / config.ship.maxHealth;
                const healthBarX = 15;

                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(healthBarX - 2, bottomBarY - 2, barWidth + 4, barHeight + 4);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(healthBarX, bottomBarY, barWidth, barHeight);

                let healthColor;
                if (healthPercent > 0.6) healthColor = '#00ff00'; // Green
                else if (healthPercent > 0.3) healthColor = '#ffff00'; // Yellow
                else healthColor = '#ff0000'; // Red

                ctx.fillStyle = healthColor;
                ctx.fillRect(healthBarX, bottomBarY, barWidth * healthPercent, barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(healthBarX, bottomBarY, barWidth, barHeight);

                // Health label and value
                ctx.fillStyle = 'white';
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('HEALTH', healthBarX, bottomBarY - 5);
                ctx.fillText(`${ship.currentHealth.toFixed(0)}/${config.ship.maxHealth}`, healthBarX, bottomBarY + barHeight + 12);

                // Afterburner bar (bottom-center)
                const energyPercent = ship.afterburnerEnergy / config.ship.afterburnerMax;
                const energyBarX = canvas.width / 2 - barWidth / 2;

                // Afterburner bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(energyBarX - 2, bottomBarY - 2, barWidth + 4, barHeight + 4);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(energyBarX, bottomBarY, barWidth, barHeight);

                let energyColor;
                if (energyPercent > 0.6) energyColor = '#ffffff'; // White
                else if (energyPercent > 0.3) energyColor = '#00ffff'; // Cyan
                else energyColor = '#0000ff'; // Blue

                ctx.fillStyle = energyColor;
                ctx.fillRect(energyBarX, bottomBarY, barWidth * energyPercent, barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(energyBarX, bottomBarY, barWidth, barHeight);

                // Afterburner label and value
                ctx.fillStyle = 'white';
                ctx.font = '11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('AFTERBURNER', energyBarX + barWidth / 2, bottomBarY - 5);
                ctx.fillText(`${ship.afterburnerEnergy.toFixed(0)}/${config.ship.afterburnerMax}`, energyBarX + barWidth / 2, bottomBarY + barHeight + 12);

                // Hit percentage display (bottom-right)
                const hitPercentage = bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100) : 0;
                const hitBarX = canvas.width - barWidth - 15;

                // Hit percentage bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(hitBarX - 2, bottomBarY - 2, barWidth + 4, barHeight + 4);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(hitBarX, bottomBarY, barWidth, barHeight);

                // Color based on hit percentage
                let hitColor;
                if (hitPercentage >= 80) hitColor = '#00ff00'; // Green - excellent
                else if (hitPercentage >= 60) hitColor = '#ffff00'; // Yellow - good
                else if (hitPercentage >= 40) hitColor = '#ff8800'; // Orange - average
                else hitColor = '#ff0000'; // Red - poor

                ctx.fillStyle = hitColor;
                ctx.fillRect(hitBarX, bottomBarY, barWidth * (hitPercentage / 100), barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(hitBarX, bottomBarY, barWidth, barHeight);

                // Hit percentage label and value
                ctx.fillStyle = 'white';
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('ACCURACY', hitBarX + barWidth, bottomBarY - 5);
                ctx.fillText(`${hitPercentage.toFixed(1)}%`, hitBarX + barWidth, bottomBarY + barHeight + 12);
            }

            // Game over screen with comprehensive statistics
            if (gameState === GAME_STATES.GAME_OVER) {
                // Semi-transparent background overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Main game over title
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, 120);

                // Final score display
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 36px Arial';
                ctx.fillText(`FINAL SCORE: ${score.toLocaleString()}`, canvas.width / 2, 180);

                // Level reached
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 24px Arial';
                ctx.fillText(`LEVEL REACHED: ${currentLevel}`, canvas.width / 2, 220);

                // Statistics section
                const statsY = 280;
                ctx.fillStyle = '#cccccc';
                ctx.font = 'bold 20px Arial';
                ctx.fillText('STATISTICS', canvas.width / 2, statsY);

                // Calculate statistics
                const accuracy = bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100) : 0;
                const totalShots = bulletsFired;
                const hits = bulletsHit;
                const playTime = Math.floor((gameEndTime - gameStartTime) / 1000); // in seconds

                ctx.fillStyle = '#ffffff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'left';

                // Left column
                const leftX = canvas.width / 2 - 150;
                ctx.fillText(`Total Shots: ${totalShots}`, leftX, statsY + 40);
                ctx.fillText(`Hits: ${hits}`, leftX, statsY + 65);
                ctx.fillText(`Accuracy: ${accuracy.toFixed(1)}%`, leftX, statsY + 90);

                // Right column
                const rightX = canvas.width / 2 + 50;
                ctx.fillText(`Play Time: ${Math.floor(playTime / 60)}:${(playTime % 60).toString().padStart(2, '0')}`, rightX, statsY + 40);
                ctx.fillText(`Enemies Defeated: ${enemiesDefeated}`, rightX, statsY + 65);

                // Performance rating based on accuracy
                let rating, ratingColor;
                if (accuracy >= 90) {
                    rating = 'LEGENDARY PILOT';
                    ratingColor = '#ffdd00';
                } else if (accuracy >= 80) {
                    rating = 'ACE PILOT';
                    ratingColor = '#00ff00';
                } else if (accuracy >= 70) {
                    rating = 'SKILLED PILOT';
                    ratingColor = '#0088ff';
                } else if (accuracy >= 60) {
                    rating = 'ADEPT PILOT';
                    ratingColor = '#ffff00';
                } else if (accuracy >= 40) {
                    rating = 'NOVICE PILOT';
                    ratingColor = '#ff8800';
                } else {
                    rating = 'RECRUIT';
                    ratingColor = '#ff4444';
                }

                ctx.fillStyle = ratingColor;
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`RATING: ${rating}`, canvas.width / 2, statsY + 140);

                // Restart instructions with blinking effect
                const blink = Math.sin(Date.now() * 0.01) > 0;
                if (blink) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText('PRESS R TO RETURN TO MAIN MENU', canvas.width / 2, canvas.height - 60);
                }

                // High score notification (simplified - will be checked when saving)
                const isHighScore = true; // We'll handle this in the saveHighScore function
                if (isHighScore && score > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText(' NEW HIGH SCORE! ', canvas.width / 2, statsY + 180);
                }
            }
        }

        function gameLoop() {
            if (gameState === GAME_STATES.PLAYING) {
                updateShip();
                updateProjectiles();
                updateEnemies();
                updateExplosions();
                updatePowerUps();
                updateParticles();
                updateScoreMultiplier();
                if (fanShotActive) {
                    fanShotVisualPhase += 0.15;
                }
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('click', () => canvas.focus());
        canvas.tabIndex = 1;

        // Audio placeholders - replace with actual audio file URLs when available
        const AUDIO_FILES = {
            shoot: '/assets/audio/shoot.wav',
            enemyShoot: '/assets/audio/enemy-shoot.wav',
            explosion: '/assets/audio/explosion.wav',
            powerup: '/assets/audio/powerup.wav',
            backgroundMusic: '/assets/audio/background.mp3'
        };

        // Sound effect functions
        function playShootSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(sfxVolume * 0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                console.log(' PEW! (shoot sound)');
            }
        }

        function playEnemyShootSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.05);

                gainNode.gain.setValueAtTime(sfxVolume * 0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.05);
            } catch (e) {
                console.log(' ZAP! (enemy shoot sound)');
            }
        }

        function playExplosionSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                // Create multiple oscillators for a richer explosion sound
                for (let i = 0; i < 3; i++) {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    const freq = 100 + Math.random() * 200;
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.01);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + i * 0.01 + 0.3);

                    gainNode.gain.setValueAtTime(sfxVolume * 0.4, audioContext.currentTime + i * 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.01 + 0.3);

                    oscillator.start(audioContext.currentTime + i * 0.01);
                    oscillator.stop(audioContext.currentTime + i * 0.01 + 0.3);
                }
            } catch (e) {
                console.log(' BOOM! (explosion sound)');
            }
        }

        function playPowerUpSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(660, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(880, audioContext.currentTime + 0.2);

                gainNode.gain.setValueAtTime(sfxVolume * 0.3, audioContext.currentTime);
                gainNode.gain.setValueAtTime(sfxVolume * 0.3, audioContext.currentTime + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log(' DING! (power-up sound)');
            }
        }

        function playThrusterSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();

                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100 + Math.random() * 50, audioContext.currentTime);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, audioContext.currentTime);

                gainNode.gain.setValueAtTime(sfxVolume * 0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (e) {
                console.log(' VROOM! (thruster sound)');
            }
        }

        function playAfterburnerSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();

                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200 + Math.random() * 100, audioContext.currentTime);

                filter.type = 'highpass';
                filter.frequency.setValueAtTime(400, audioContext.currentTime);

                gainNode.gain.setValueAtTime(sfxVolume * 0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log(' WHOOSH! (afterburner sound)');
            }
        }

        function playBackgroundMusic() {
            if (!audioEnabled || !audioContext) return;
            try {
                // Simple ambient background tone
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();

                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(80, audioContext.currentTime);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioContext.currentTime);

                gainNode.gain.setValueAtTime(musicVolume * 0.1, audioContext.currentTime);

                oscillator.start(audioContext.currentTime);

                // Store reference to stop later
                currentMusic = oscillator;
            } catch (e) {
                console.log(' Background music playing');
            }
        }

        function stopBackgroundMusic() {
            if (currentMusic) {
                try {
                    currentMusic.stop();
                } catch (error) {
                    // Music might already be stopped
                }
                currentMusic = null;
                console.log(' Background music stopped');
            }
        }

        // Audio controls UI (simple keyboard shortcuts for now)
        function setupAudioControls() {
            document.addEventListener('keydown', (e) => {
                // Audio control shortcuts
                if (e.key === 'm' || e.key === 'M') {
                    // Toggle mute
                    audioEnabled = !audioEnabled;
                    if (!audioEnabled) {
                        stopAllAudio();
                    }
                    console.log(` Audio ${audioEnabled ? 'enabled' : 'muted'}`);
                } else if (e.key === '9') {
                    // Decrease master volume
                    setMasterVolume(masterVolume - 0.1);
                    console.log(` Master volume: ${(masterVolume * 100).toFixed(0)}%`);
                } else if (e.key === '0') {
                    // Increase master volume
                    setMasterVolume(masterVolume + 0.1);
                    console.log(` Master volume: ${(masterVolume * 100).toFixed(0)}%`);
                }
            });
        }

        // Initialize game with config loading
        async function initGame() {
            await loadConfig();
            applyConfig();
            initAudio();
            setupAudioControls();
            initAuth();
            handleAuthCallback();
            gameLoop(); // Start the render loop, but game stays in START state
        }

        initGame();
    </script>
</body>
</html>