<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Frontier</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            height: 100vh;
            display: flex;
        }

        /* Left sidebar for banner ads */
        .left-sidebar {
            width: 200px;
            background: #111;
            border-right: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-family: Arial, sans-serif;
            font-size: 14px;
            text-align: center;
        }

        /* Game canvas container */
        .game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            display: block;
            height: 100vh;
            width: auto;
            max-width: calc(100vw - 400px); /* Account for both sidebars */
        }

        /* Right sidebar for top scores */
        .right-sidebar {
            width: 200px;
            background: #111;
            border-left: 2px solid #333;
            display: flex;
            flex-direction: column;
            padding: 20px;
            color: white;
            font-family: Arial, sans-serif;
        }

        .right-sidebar h3 {
            margin: 0 0 15px 0;
            color: #00ff00;
            font-size: 18px;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .score-name {
            color: #fff;
        }

        .score-value {
            color: #00ff00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Left sidebar for banner advertisements -->
    <div class="left-sidebar">
        <div>
            <div style="font-size: 16px; margin-bottom: 10px;">Advertisement</div>
            <div style="font-size: 12px; opacity: 0.7;">Banner Space</div>
        </div>
    </div>

    <!-- Game canvas container -->
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Right sidebar for top scores -->
    <div class="right-sidebar">
        <h3>TOP SCORES</h3>
        <div id="topScores">
            <div class="score-item">
                <span class="score-name">PLAYER 1</span>
                <span class="score-value">250</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 2</span>
                <span class="score-value">200</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 3</span>
                <span class="score-value">180</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 4</span>
                <span class="score-value">150</span>
            </div>
            <div class="score-item">
                <span class="score-name">PLAYER 5</span>
                <span class="score-value">120</span>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Global config variable
        let config = null;

        // Canvas resize function
        function resizeCanvas() {
            const viewportHeight = window.innerHeight;
            const availableWidth = window.innerWidth - 400; // Subtract sidebar widths (200px each)

            // Set canvas to full height and available width
            canvas.width = Math.max(800, availableWidth); // Minimum width of 800px
            canvas.height = viewportHeight;

            // Update canvas style to match
            canvas.style.width = canvas.width + 'px';
            canvas.style.height = canvas.height + 'px';
        }

        // Initialize canvas size
        resizeCanvas();

        // Handle window resize
        window.addEventListener('resize', resizeCanvas);

        // Function to update top scores display
        function updateTopScores(scores) {
            const topScoresDiv = document.getElementById('topScores');
            if (!topScoresDiv) return;

            topScoresDiv.innerHTML = scores.map((score, index) => `
                <div class="score-item">
                    <span class="score-name">${score.name || `PLAYER ${index + 1}`}</span>
                    <span class="score-value">${score.value || 0}</span>
                </div>
            `).join('');
        }

        // Initialize with placeholder scores
        const placeholderScores = [
            { name: 'PLAYER 1', value: 250 },
            { name: 'PLAYER 2', value: 200 },
            { name: 'PLAYER 3', value: 180 },
            { name: 'PLAYER 4', value: 150 },
            { name: 'PLAYER 5', value: 120 }
        ];
        updateTopScores(placeholderScores);

        let configLoaded = false;

        // Config loading function
        async function loadConfig() {
            try {
                console.log('Loading game configuration...');
                const response = await fetch('/config/config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                config = await response.json();
                console.log('Configuration loaded successfully:', config);
                configLoaded = true;
                return config;
            } catch (error) {
                console.error('Failed to load configuration:', error);
                // Provide fallback defaults
                config = {
                    ship: {
                        maxSpeed: 5,
                        thrust: 0.1,
                        afterburnerBoost: 2,
                        afterburnerMax: 100,
                        afterburnerDepleteRate: 5,
                        afterburnerRegenRate: 1,
                        maxHealth: 100,
                        size: 20
                    },
                    projectiles: {
                        speed: 7,
                        life: 100,
                        fanShotCount: 10,
                        fanShotAngle: 0.1047,
                        cooldown: 10
                    },
                    enemies: [
                        { type: 'small', size: 10, speed: 3, points: 10, shootInterval: 120, projectileDamage: 1.25, collisionDamage: 3.75 },
                        { type: 'medium', size: 15, speed: 2, points: 20, shootInterval: 90, projectileDamage: 2.5, collisionDamage: 7.5 },
                        { type: 'large', size: 25, speed: 1, points: 50, shootInterval: 60, projectileDamage: 5, collisionDamage: 12.5 }
                    ],
                    game: {
                        scoreToLevelUp: 250,
                        minSpawnInterval: 60,
                        maxSpawnInterval: 300,
                        minHealthSpawnInterval: 300,
                        maxHealthSpawnInterval: 600,
                        minFanShotSpawnInterval: 600,
                        maxFanShotSpawnInterval: 1200,
                        healthPowerUpValue: 10,
                        fanShotDuration: 600
                    }
                };
                console.warn('Using fallback configuration');
                configLoaded = true;
                return config;
            }
        }

        // Player ship
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            speed: 0,
            maxSpeed: 5, // Will be replaced with config value
            thrust: 0.1, // Will be replaced with config value
            size: 20, // Will be replaced with config value
            currentHealth: 100, // Will be replaced with config value
            afterburnerEnergy: 100, // Will be replaced with config value
            lastShot: 0
        };

        // Universe coordinates
        let universeX = 0;
        let universeY = 0;

        // Projectiles (player)
        const projectiles = [];
        let projectileSpeed = 7; // Will be replaced with config value
        let projectileLife = 100; // Will be replaced with config value
        let projectileCooldown = 10; // Will be replaced with config value

        // Enemy projectiles
        const enemyProjectiles = [];

        // Enemies
        const enemies = [];
        let spawnTimer = 0;
        let minSpawnInterval = 60; // Will be replaced with config value
        let maxSpawnInterval = 300; // Will be replaced with config value
        let nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
        let baseEnemyTypes = []; // Will be loaded from config

        // Explosions
        const explosions = [];

        // Game states
        const GAME_STATES = {
            START: 'start',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver'
        };
        let gameState = GAME_STATES.START;

        // Scoreboard and levels
        let score = 0;
        let bulletsFired = 0;
        let bulletsHit = 0;
        let currentLevel = 1;
        let scoreToLevelUp = 500; // Will be replaced with config value

        // Apply config values to game variables
        function applyConfig() {
            if (!config) return;

            // Ship configuration
            ship.maxSpeed = config.ship.maxSpeed;
            ship.thrust = config.ship.thrust;
            ship.size = config.ship.size;
            ship.currentHealth = config.ship.maxHealth;
            ship.afterburnerEnergy = config.ship.afterburnerMax;

            // Projectile configuration
            projectileSpeed = config.projectiles.speed;
            projectileLife = config.projectiles.life;
            projectileCooldown = config.projectiles.cooldown;

            // Enemy configuration
            baseEnemyTypes = config.enemies;

            // Game configuration
            scoreToLevelUp = config.game.scoreToLevelUp;
            minSpawnInterval = config.game.minSpawnInterval;
            maxSpawnInterval = config.game.maxSpawnInterval;

            console.log('Configuration applied to game variables');
        }

        // Control state variables
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let thrustPressed = false;
        let afterburnerPressed = false;
        let rightMousePressed = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            // Ensure mouse coordinates stay within canvas bounds
            mouseX = Math.max(0, Math.min(mouseX, canvas.width));
            mouseY = Math.max(0, Math.min(mouseY, canvas.height));
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 0) { // Left mouse button
                e.preventDefault(); // Prevent context menu
                rightMousePressed = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 0) { // Left mouse button
                rightMousePressed = false;
            }
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        document.addEventListener('keydown', (e) => {
            if (gameState === GAME_STATES.START) {
                if (e.key === ' ' || e.key === 'Enter') {
                    startGame();
                }
            } else if (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.PAUSED) {
                if (e.key === 'p' || e.key === 'P') {
                    togglePause();
                } else if (gameState === GAME_STATES.PLAYING) {
                    if (e.key === 'w' || e.key === 'W') thrustPressed = true;
                    if (e.key === ' ') {
                        e.preventDefault(); // Prevent page scroll
                        afterburnerPressed = true;
                    }
                }
            } else if (gameState === GAME_STATES.GAME_OVER) {
                if (e.key === 'r' || e.key === 'R') {
                    gameState = GAME_STATES.START;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameState === GAME_STATES.PLAYING) {
                if (e.key === 'w' || e.key === 'W') thrustPressed = false;
                if (e.key === ' ') afterburnerPressed = false;
            }
        });

        // Stars
        const stars = [];
        for (let i = 0; i < 500; i++) {
            stars.push({
                universeX: (Math.random() - 0.5) * 8000,
                universeY: (Math.random() - 0.5) * 8000,
                size: Math.random() * 2 + 1
            });
        }

        function startGame() {
            gameState = GAME_STATES.PLAYING;
            resetGame();
        }

        function resetGame() {
            ship.currentHealth = config ? config.ship.maxHealth : 100;
            ship.afterburnerEnergy = config ? config.ship.afterburnerMax : 100;
            ship.speed = 0;
            ship.angle = 0;
            universeX = 0;
            universeY = 0;
            score = 0;
            bulletsFired = 0;
            bulletsHit = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            enemies.length = 0;
            explosions.length = 0;
            spawnTimer = 0;
            nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
            currentLevel = 1;
            gameState = GAME_STATES.PLAYING;
        }

        function endGame() {
            gameState = GAME_STATES.GAME_OVER;
        }

        function togglePause() {
            if (gameState === GAME_STATES.PLAYING) {
                gameState = GAME_STATES.PAUSED;
            } else if (gameState === GAME_STATES.PAUSED) {
                gameState = GAME_STATES.PLAYING;
            }
        }

        function drawStartScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC FRONTIER', canvas.width / 2, canvas.height / 2 - 100);

            // Instructions
            ctx.font = '20px Arial';
            ctx.fillText('Controls:', canvas.width / 2, canvas.height / 2 - 40);
            ctx.font = '16px Arial';
            ctx.fillText('Mouse Movement - Rotate Ship', canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText('W - Thrust Forward', canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText('Spacebar - Afterburner (Limited Energy)', canvas.width / 2, canvas.height / 2 + 30);
            ctx.fillText('Left Mouse Button - Shoot', canvas.width / 2, canvas.height / 2 + 50);
            ctx.fillText('P - Pause/Resume', canvas.width / 2, canvas.height / 2 + 70);

            // Start prompt
            ctx.font = '24px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('Press SPACEBAR or ENTER to Start', canvas.width / 2, canvas.height / 2 + 100);

            // Version/Config info
            ctx.font = '12px Arial';
            ctx.fillStyle = 'gray';
            ctx.textAlign = 'left';
            ctx.fillText('Phase 1: Core Game Mechanics', 10, canvas.height - 20);
            ctx.textAlign = 'right';
            ctx.fillText('Configuration Loaded', canvas.width - 10, canvas.height - 20);
        }

        function drawPauseScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pause text
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 50);

            // Instructions
            ctx.font = '24px Arial';
            ctx.fillText('Press P to Resume', canvas.width / 2, canvas.height / 2 + 20);

            // Game stats (in arcade style layout)
            ctx.font = '20px Arial';
            ctx.fillText(`LEVEL ${currentLevel}     SCORE ${score}/${scoreToLevelUp}`, canvas.width / 2, canvas.height / 2 + 70);

            // Health and Afterburner bars
            const barWidth = 120;
            const barHeight = 14;
            const barY = canvas.height / 2 + 90;

            // Health bar (left)
            const healthPercent = ship.currentHealth / config.ship.maxHealth;
            const healthBarX = canvas.width / 2 - barWidth - 20;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(healthBarX, barY, barWidth, barHeight);

            let healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
            ctx.fillStyle = healthColor;
            ctx.fillRect(healthBarX, barY, barWidth * healthPercent, barHeight);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(healthBarX, barY, barWidth, barHeight);

            // Afterburner bar (right)
            const energyPercent = ship.afterburnerEnergy / config.ship.afterburnerMax;
            const energyBarX = canvas.width / 2 + 20;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(energyBarX, barY, barWidth, barHeight);

            let energyColor = energyPercent > 0.6 ? '#ffffff' : energyPercent > 0.3 ? '#00ffff' : '#0000ff';
            ctx.fillStyle = energyColor;
            ctx.fillRect(energyBarX, barY, barWidth * energyPercent, barHeight);

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(energyBarX, barY, barWidth, barHeight);

            // Stats at bottom
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText(`SHOTS: ${bulletsFired}     ACCURACY: ${bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100).toFixed(1) : 0}%`, canvas.width / 2, canvas.height / 2 + 130);
        }

        function spawnEnemy() {
            const rand = Math.random();
            let type;
            if (rand < 0.5) type = baseEnemyTypes[0];
            else if (rand < 0.8) type = baseEnemyTypes[1];
            else type = baseEnemyTypes[2];

            const damageMultiplier = Math.pow(1.1, currentLevel - 1); // 10% increase per level

            const angle = Math.random() * Math.PI * 2;
            const distance = 500;
            enemies.push({
                universeX: universeX + Math.cos(angle) * distance,
                universeY: universeY + Math.sin(angle) * distance,
                angle: 0,
                speed: type.speed,
                size: type.size,
                points: type.points,
                type: type.type,
                shootTimer: Math.random() * type.shootInterval,
                projectileDamage: type.projectileDamage * damageMultiplier,
                collisionDamage: type.collisionDamage * damageMultiplier
            });
        }

        function updateShip() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            ship.angle = Math.atan2(mouseY - ship.y, mouseX - ship.x);

            // Handle thrust (W key)
            if (thrustPressed) {
                ship.speed = Math.min(ship.speed + ship.thrust, ship.maxSpeed);
            } else {
                ship.speed = Math.max(ship.speed - ship.thrust / 2, 0);
            }

            // Handle afterburner (spacebar) - only if energy available
            let effectiveSpeed = ship.speed;
            if (afterburnerPressed && ship.afterburnerEnergy > 0) {
                effectiveSpeed *= config.ship.afterburnerBoost;
                ship.afterburnerEnergy = Math.max(0, ship.afterburnerEnergy - config.ship.afterburnerDepleteRate);
            } else if (ship.afterburnerEnergy < config.ship.afterburnerMax) {
                ship.afterburnerEnergy = Math.min(config.ship.afterburnerMax, ship.afterburnerEnergy + config.ship.afterburnerRegenRate);
            }

            universeX += Math.cos(ship.angle) * effectiveSpeed;
            universeY += Math.sin(ship.angle) * effectiveSpeed;

            // Handle shooting (left mouse button)
            if (rightMousePressed && ship.lastShot <= 0) {
                projectiles.push({
                    universeX: universeX,
                    universeY: universeY,
                    angle: ship.angle,
                    life: projectileLife
                });
                bulletsFired++;
                ship.lastShot = projectileCooldown;
            }
            if (ship.lastShot > 0) ship.lastShot--;
        }

        function updateProjectiles() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            // Player projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(p.universeX - e.universeX, p.universeY - e.universeY);
                    if (dist < e.size) {
                        explosions.push({
                            universeX: e.universeX,
                            universeY: e.universeY,
                            radius: 0,
                            life: 20
                        });
                        score += e.points;
                        bulletsHit++;
                        enemies.splice(j, 1);
                        projectiles.splice(i, 1);
                        // Check for level-up
                        if (score >= scoreToLevelUp) {
                            currentLevel++;
                            score = 0; // Reset score for new level
                            enemies.length = 0; // Clear enemies
                            enemyProjectiles.length = 0; // Clear enemy projectiles
                        }
                        break;
                    }
                }
            }

            // Enemy projectiles
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                const dist = Math.hypot(p.universeX - universeX, p.universeY - universeY);
                if (dist < ship.size) {
                    ship.currentHealth = Math.max(0, ship.currentHealth - p.damage);
                    enemyProjectiles.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateEnemies() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            spawnTimer++;
            if (spawnTimer >= nextSpawn) {
                spawnEnemy();
                spawnTimer = 0;
                nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dx = universeX - e.universeX;
                const dy = universeY - e.universeY;
                e.angle = Math.atan2(dy, dx);
                e.universeX += Math.cos(e.angle) * e.speed;
                e.universeY += Math.sin(e.angle) * e.speed;

                e.shootTimer++;
                if (e.shootTimer >= e.shootInterval) {
                    enemyProjectiles.push({
                        universeX: e.universeX,
                        universeY: e.universeY,
                        angle: e.angle,
                        life: projectileLife,
                        damage: e.projectileDamage
                    });
                    e.shootTimer = 0;
                }

                const dist = Math.hypot(e.universeX - universeX, e.universeY - universeY);
                if (dist < e.size + ship.size) {
                    explosions.push({
                        universeX: e.universeX,
                        universeY: e.universeY,
                        radius: 0,
                        life: 20
                    });
                    ship.currentHealth = Math.max(0, ship.currentHealth - e.collisionDamage);
                    enemies.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateExplosions() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.radius += 2;
                exp.life--;
                if (exp.life <= 0) explosions.splice(i, 1);
            }
        }

        function draw() {
            if (gameState === GAME_STATES.START) {
                drawStartScreen();
                return;
            }

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw game world
            drawGame();

            // Draw pause overlay if paused
            if (gameState === GAME_STATES.PAUSED) {
                drawPauseScreen();
            }
        }

        function drawGame() {

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw projectiles
            ctx.fillStyle = 'white';
            projectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemy projectiles
            ctx.fillStyle = 'orange';
            enemyProjectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemies
            enemies.forEach(e => {
                const screenX = e.universeX - universeX + canvas.width / 2;
                const screenY = e.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(e.angle);
                    ctx.beginPath();
                    if (e.type === 'small') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(-e.size / 2, e.size / 2);
                        ctx.lineTo(-e.size / 2, -e.size / 2);
                    } else if (e.type === 'medium') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(0, e.size / 2);
                        ctx.lineTo(-e.size, 0);
                        ctx.lineTo(0, -e.size / 2);
                    } else {
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            const x = e.size * Math.cos(angle);
                            const y = e.size * Math.sin(angle);
                            ctx[i === 0 ? 'moveTo' : 'lineTo'](x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Draw explosions
            ctx.strokeStyle = 'yellow';
            explosions.forEach(exp => {
                const screenX = exp.universeX - universeX + canvas.width / 2;
                const screenY = exp.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, exp.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw spaceship
            if (gameState === GAME_STATES.PLAYING) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);
                ctx.beginPath();
                ctx.moveTo(ship.size, 0);
                ctx.lineTo(ship.size * 0.3, ship.size * 0.5);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.5);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.3, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, -ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, -ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.restore();
            }

            // Draw scoreboard and UI (only during gameplay)
            if (gameState === GAME_STATES.PLAYING) {
                // Top HUD - Score and Level centered
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`LEVEL ${currentLevel}     SCORE ${score}/${scoreToLevelUp}`, canvas.width / 2, 25);

                // Top bars - Health and Afterburner side by side
                const barWidth = 150;
                const barHeight = 16;
                const barY = 40;

                // Health bar (left side)
                const healthPercent = ship.currentHealth / config.ship.maxHealth;
                const healthBarX = 10;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(healthBarX, barY, barWidth, barHeight);

                let healthColor;
                if (healthPercent > 0.6) healthColor = '#00ff00'; // Green
                else if (healthPercent > 0.3) healthColor = '#ffff00'; // Yellow
                else healthColor = '#ff0000'; // Red

                ctx.fillStyle = healthColor;
                ctx.fillRect(healthBarX, barY, barWidth * healthPercent, barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(healthBarX, barY, barWidth, barHeight);

                // Health label
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`HEALTH ${ship.currentHealth.toFixed(0)}/${config.ship.maxHealth}`, healthBarX, barY - 3);

                // Afterburner bar (right side)
                const energyPercent = ship.afterburnerEnergy / config.ship.afterburnerMax;
                const energyBarX = canvas.width - barWidth - 10;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(energyBarX, barY, barWidth, barHeight);

                let energyColor;
                if (energyPercent > 0.6) energyColor = '#ffffff'; // White
                else if (energyPercent > 0.3) energyColor = '#00ffff'; // Cyan
                else energyColor = '#0000ff'; // Blue

                ctx.fillStyle = energyColor;
                ctx.fillRect(energyBarX, barY, barWidth * energyPercent, barHeight);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(energyBarX, barY, barWidth, barHeight);

                // Afterburner label
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`AFTERBURNER ${ship.afterburnerEnergy.toFixed(0)}/${config.ship.afterburnerMax}`, energyBarX + barWidth, barY - 3);

                // Bottom stats
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`SHOTS: ${bulletsFired}`, 10, canvas.height - 30);
                ctx.fillText(`ACCURACY: ${bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100).toFixed(1) : 0}%`, 10, canvas.height - 10);
            }

            // Game over
            if (gameState === GAME_STATES.GAME_OVER) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
                ctx.font = '20px Arial';
                ctx.fillText(`Final Score: ${score} (Level ${currentLevel})`, canvas.width / 2, canvas.height / 2 + 40);
                ctx.fillText('Press R to Return to Main Menu', canvas.width / 2, canvas.height / 2 + 80);
            }
        }

        function gameLoop() {
            if (gameState === GAME_STATES.PLAYING) {
                updateShip();
                updateProjectiles();
                updateEnemies();
                updateExplosions();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('click', () => canvas.focus());
        canvas.tabIndex = 1;

        // Initialize game with config loading
        async function initGame() {
            await loadConfig();
            applyConfig();
            gameLoop(); // Start the render loop, but game stays in START state
        }

        initGame();
    </script>
</body>
</html>