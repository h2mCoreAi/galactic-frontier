<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escape Velocity Mockup</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Global config variable
        let config = null;
        let configLoaded = false;

        // Config loading function
        async function loadConfig() {
            try {
                console.log('Loading game configuration...');
                const response = await fetch('/config/config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                config = await response.json();
                console.log('Configuration loaded successfully:', config);
                configLoaded = true;
                return config;
            } catch (error) {
                console.error('Failed to load configuration:', error);
                // Provide fallback defaults
                config = {
                    ship: {
                        maxSpeed: 5,
                        thrust: 0.1,
                        afterburnerBoost: 2,
                        afterburnerMax: 100,
                        afterburnerDepleteRate: 5,
                        afterburnerRegenRate: 1,
                        maxHealth: 100,
                        size: 20
                    },
                    projectiles: {
                        speed: 7,
                        life: 100,
                        fanShotCount: 10,
                        fanShotAngle: 0.1047,
                        cooldown: 10
                    },
                    enemies: [
                        { type: 'small', size: 10, speed: 3, points: 10, shootInterval: 120, projectileDamage: 1.25, collisionDamage: 3.75 },
                        { type: 'medium', size: 15, speed: 2, points: 20, shootInterval: 90, projectileDamage: 2.5, collisionDamage: 7.5 },
                        { type: 'large', size: 25, speed: 1, points: 50, shootInterval: 60, projectileDamage: 5, collisionDamage: 12.5 }
                    ],
                    game: {
                        scoreToLevelUp: 250,
                        minSpawnInterval: 60,
                        maxSpawnInterval: 300,
                        minHealthSpawnInterval: 300,
                        maxHealthSpawnInterval: 600,
                        minFanShotSpawnInterval: 600,
                        maxFanShotSpawnInterval: 1200,
                        healthPowerUpValue: 10,
                        fanShotDuration: 600
                    }
                };
                console.warn('Using fallback configuration');
                configLoaded = true;
                return config;
            }
        }

        // Player ship
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0,
            speed: 0,
            maxSpeed: 5, // Will be replaced with config value
            thrust: 0.1, // Will be replaced with config value
            size: 20, // Will be replaced with config value
            currentHealth: 100, // Will be replaced with config value
            afterburnerEnergy: 100, // Will be replaced with config value
            lastShot: 0
        };

        // Universe coordinates
        let universeX = 0;
        let universeY = 0;

        // Projectiles (player)
        const projectiles = [];
        let projectileSpeed = 7; // Will be replaced with config value
        let projectileLife = 100; // Will be replaced with config value
        let projectileCooldown = 10; // Will be replaced with config value

        // Enemy projectiles
        const enemyProjectiles = [];

        // Enemies
        const enemies = [];
        let spawnTimer = 0;
        let minSpawnInterval = 60; // Will be replaced with config value
        let maxSpawnInterval = 300; // Will be replaced with config value
        let nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
        let baseEnemyTypes = []; // Will be loaded from config

        // Explosions
        const explosions = [];

        // Game states
        const GAME_STATES = {
            START: 'start',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver'
        };
        let gameState = GAME_STATES.START;

        // Scoreboard and levels
        let score = 0;
        let bulletsFired = 0;
        let bulletsHit = 0;
        let currentLevel = 1;
        let scoreToLevelUp = 500; // Will be replaced with config value

        // Apply config values to game variables
        function applyConfig() {
            if (!config) return;

            // Ship configuration
            ship.maxSpeed = config.ship.maxSpeed;
            ship.thrust = config.ship.thrust;
            ship.size = config.ship.size;
            ship.currentHealth = config.ship.maxHealth;
            ship.afterburnerEnergy = config.ship.afterburnerMax;

            // Projectile configuration
            projectileSpeed = config.projectiles.speed;
            projectileLife = config.projectiles.life;
            projectileCooldown = config.projectiles.cooldown;

            // Enemy configuration
            baseEnemyTypes = config.enemies;

            // Game configuration
            scoreToLevelUp = config.game.scoreToLevelUp;
            minSpawnInterval = config.game.minSpawnInterval;
            maxSpawnInterval = config.game.maxSpawnInterval;

            console.log('Configuration applied to game variables');
        }

        // Control state variables
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let thrustPressed = false;
        let afterburnerPressed = false;
        let rightMousePressed = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 2) { // Right mouse button
                e.preventDefault(); // Prevent context menu
                rightMousePressed = true;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (gameState === GAME_STATES.PLAYING && e.button === 2) { // Right mouse button
                rightMousePressed = false;
            }
        });

        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        document.addEventListener('keydown', (e) => {
            if (gameState === GAME_STATES.START) {
                if (e.key === ' ' || e.key === 'Enter') {
                    startGame();
                }
            } else if (gameState === GAME_STATES.PLAYING) {
                if (e.key === 'w' || e.key === 'W') thrustPressed = true;
                if (e.key === ' ') {
                    e.preventDefault(); // Prevent page scroll
                    afterburnerPressed = true;
                }
            } else if (gameState === GAME_STATES.GAME_OVER) {
                if (e.key === 'r' || e.key === 'R') {
                    gameState = GAME_STATES.START;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameState === GAME_STATES.PLAYING) {
                if (e.key === 'w' || e.key === 'W') thrustPressed = false;
                if (e.key === ' ') afterburnerPressed = false;
            }
        });

        // Stars
        const stars = [];
        for (let i = 0; i < 500; i++) {
            stars.push({
                universeX: (Math.random() - 0.5) * 8000,
                universeY: (Math.random() - 0.5) * 8000,
                size: Math.random() * 2 + 1
            });
        }

        function startGame() {
            gameState = GAME_STATES.PLAYING;
            resetGame();
        }

        function resetGame() {
            ship.currentHealth = config ? config.ship.maxHealth : 100;
            ship.afterburnerEnergy = config ? config.ship.afterburnerMax : 100;
            ship.speed = 0;
            ship.angle = 0;
            universeX = 0;
            universeY = 0;
            score = 0;
            bulletsFired = 0;
            bulletsHit = 0;
            projectiles.length = 0;
            enemyProjectiles.length = 0;
            enemies.length = 0;
            explosions.length = 0;
            spawnTimer = 0;
            nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
            currentLevel = 1;
            gameState = GAME_STATES.PLAYING;
        }

        function endGame() {
            gameState = GAME_STATES.GAME_OVER;
        }

        function drawStartScreen() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Title
            ctx.fillStyle = 'white';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GALACTIC FRONTIER', canvas.width / 2, canvas.height / 2 - 100);

            // Instructions
            ctx.font = '20px Arial';
            ctx.fillText('Controls:', canvas.width / 2, canvas.height / 2 - 40);
            ctx.font = '16px Arial';
            ctx.fillText('Mouse Movement - Rotate Ship', canvas.width / 2, canvas.height / 2 - 10);
            ctx.fillText('W - Thrust Forward', canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText('Spacebar - Afterburner (Limited Energy)', canvas.width / 2, canvas.height / 2 + 30);
            ctx.fillText('Right Mouse Button - Shoot', canvas.width / 2, canvas.height / 2 + 50);

            // Start prompt
            ctx.font = '24px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.fillText('Press SPACEBAR or ENTER to Start', canvas.width / 2, canvas.height / 2 + 100);

            // Version/Config info
            ctx.font = '12px Arial';
            ctx.fillStyle = 'gray';
            ctx.textAlign = 'left';
            ctx.fillText('Phase 1: Core Game Mechanics', 10, canvas.height - 20);
            ctx.textAlign = 'right';
            ctx.fillText('Configuration Loaded', canvas.width - 10, canvas.height - 20);
        }

        function spawnEnemy() {
            const rand = Math.random();
            let type;
            if (rand < 0.5) type = baseEnemyTypes[0];
            else if (rand < 0.8) type = baseEnemyTypes[1];
            else type = baseEnemyTypes[2];

            const damageMultiplier = Math.pow(1.1, currentLevel - 1); // 10% increase per level

            const angle = Math.random() * Math.PI * 2;
            const distance = 500;
            enemies.push({
                universeX: universeX + Math.cos(angle) * distance,
                universeY: universeY + Math.sin(angle) * distance,
                angle: 0,
                speed: type.speed,
                size: type.size,
                points: type.points,
                type: type.type,
                shootTimer: Math.random() * type.shootInterval,
                projectileDamage: type.projectileDamage * damageMultiplier,
                collisionDamage: type.collisionDamage * damageMultiplier
            });
        }

        function updateShip() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            ship.angle = Math.atan2(mouseY - ship.y, mouseX - ship.x);

            // Handle thrust (W key)
            if (thrustPressed) {
                ship.speed = Math.min(ship.speed + ship.thrust, ship.maxSpeed);
            } else {
                ship.speed = Math.max(ship.speed - ship.thrust / 2, 0);
            }

            // Handle afterburner (spacebar) - only if energy available
            let effectiveSpeed = ship.speed;
            if (afterburnerPressed && ship.afterburnerEnergy > 0) {
                effectiveSpeed *= config.ship.afterburnerBoost;
                ship.afterburnerEnergy = Math.max(0, ship.afterburnerEnergy - config.ship.afterburnerDepleteRate);
            } else if (ship.afterburnerEnergy < config.ship.afterburnerMax) {
                ship.afterburnerEnergy = Math.min(config.ship.afterburnerMax, ship.afterburnerEnergy + config.ship.afterburnerRegenRate);
            }

            universeX += Math.cos(ship.angle) * effectiveSpeed;
            universeY += Math.sin(ship.angle) * effectiveSpeed;

            // Handle shooting (right mouse button)
            if (rightMousePressed && ship.lastShot <= 0) {
                projectiles.push({
                    universeX: universeX,
                    universeY: universeY,
                    angle: ship.angle,
                    life: projectileLife
                });
                bulletsFired++;
                ship.lastShot = projectileCooldown;
            }
            if (ship.lastShot > 0) ship.lastShot--;
        }

        function updateProjectiles() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            // Player projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dist = Math.hypot(p.universeX - e.universeX, p.universeY - e.universeY);
                    if (dist < e.size) {
                        explosions.push({
                            universeX: e.universeX,
                            universeY: e.universeY,
                            radius: 0,
                            life: 20
                        });
                        score += e.points;
                        bulletsHit++;
                        enemies.splice(j, 1);
                        projectiles.splice(i, 1);
                        // Check for level-up
                        if (score >= scoreToLevelUp) {
                            currentLevel++;
                            score = 0; // Reset score for new level
                            enemies.length = 0; // Clear enemies
                            enemyProjectiles.length = 0; // Clear enemy projectiles
                        }
                        break;
                    }
                }
            }

            // Enemy projectiles
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.universeX += Math.cos(p.angle) * projectileSpeed;
                p.universeY += Math.sin(p.angle) * projectileSpeed;
                p.life--;
                if (p.life <= 0) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                const dist = Math.hypot(p.universeX - universeX, p.universeY - universeY);
                if (dist < ship.size) {
                    ship.currentHealth = Math.max(0, ship.currentHealth - p.damage);
                    enemyProjectiles.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateEnemies() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            spawnTimer++;
            if (spawnTimer >= nextSpawn) {
                spawnEnemy();
                spawnTimer = 0;
                nextSpawn = Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dx = universeX - e.universeX;
                const dy = universeY - e.universeY;
                e.angle = Math.atan2(dy, dx);
                e.universeX += Math.cos(e.angle) * e.speed;
                e.universeY += Math.sin(e.angle) * e.speed;

                e.shootTimer++;
                if (e.shootTimer >= e.shootInterval) {
                    enemyProjectiles.push({
                        universeX: e.universeX,
                        universeY: e.universeY,
                        angle: e.angle,
                        life: projectileLife,
                        damage: e.projectileDamage
                    });
                    e.shootTimer = 0;
                }

                const dist = Math.hypot(e.universeX - universeX, e.universeY - universeY);
                if (dist < e.size + ship.size) {
                    explosions.push({
                        universeX: e.universeX,
                        universeY: e.universeY,
                        radius: 0,
                        life: 20
                    });
                    ship.currentHealth = Math.max(0, ship.currentHealth - e.collisionDamage);
                    enemies.splice(i, 1);
                    if (ship.currentHealth <= 0) endGame();
                }
            }
        }

        function updateExplosions() {
            if (gameState !== GAME_STATES.PLAYING || !configLoaded) return;

            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.radius += 2;
                exp.life--;
                if (exp.life <= 0) explosions.splice(i, 1);
            }
        }

        function draw() {
            if (gameState === GAME_STATES.START) {
                drawStartScreen();
                return;
            }

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                const screenX = star.universeX - universeX + canvas.width / 2;
                const screenY = star.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw projectiles
            ctx.fillStyle = 'white';
            projectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemy projectiles
            ctx.fillStyle = 'orange';
            enemyProjectiles.forEach(p => {
                const screenX = p.universeX - universeX + canvas.width / 2;
                const screenY = p.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.fillRect(screenX - 2, screenY - 1, 4, 2);
                }
            });

            // Draw enemies
            enemies.forEach(e => {
                const screenX = e.universeX - universeX + canvas.width / 2;
                const screenY = e.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(e.angle);
                    ctx.beginPath();
                    if (e.type === 'small') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(-e.size / 2, e.size / 2);
                        ctx.lineTo(-e.size / 2, -e.size / 2);
                    } else if (e.type === 'medium') {
                        ctx.moveTo(e.size, 0);
                        ctx.lineTo(0, e.size / 2);
                        ctx.lineTo(-e.size, 0);
                        ctx.lineTo(0, -e.size / 2);
                    } else {
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            const x = e.size * Math.cos(angle);
                            const y = e.size * Math.sin(angle);
                            ctx[i === 0 ? 'moveTo' : 'lineTo'](x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Draw explosions
            ctx.strokeStyle = 'yellow';
            explosions.forEach(exp => {
                const screenX = exp.universeX - universeX + canvas.width / 2;
                const screenY = exp.universeY - universeY + canvas.height / 2;
                if (screenX >= 0 && screenX <= canvas.width && screenY >= 0 && screenY <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, exp.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw spaceship
            if (!gameOver) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);
                ctx.beginPath();
                ctx.moveTo(ship.size, 0);
                ctx.lineTo(ship.size * 0.3, ship.size * 0.5);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.5);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.3, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.lineTo(ship.size * 0.3, -ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, ship.size * 0.3);
                ctx.closePath();
                ctx.moveTo(ship.size * 0.1, -ship.size * 0.3);
                ctx.lineTo(-ship.size * 0.7, -ship.size * 0.8);
                ctx.lineTo(-ship.size * 0.5, -ship.size * 0.3);
                ctx.closePath();
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.restore();
            }

            // Draw scoreboard
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Controls: Mouse Move (Rotate), W (Thrust), Space (Afterburner), Right Click (Shoot)', 10, 20);
            ctx.fillText('Click canvas to focus', 10, 40);
            ctx.fillText(`Level: ${currentLevel}`, 10, 60);
            ctx.fillText(`Score: ${score}/${scoreToLevelUp}`, 10, 80);
            // Health bar
            const healthPercent = ship.currentHealth / config.ship.maxHealth;
            const barWidth = 200;
            const barHeight = 20;
            const barX = 10;
            const barY = 100;

            // Health bar background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Health bar fill with color coding
            let healthColor;
            if (healthPercent > 0.6) healthColor = '#00ff00'; // Green
            else if (healthPercent > 0.3) healthColor = '#ffff00'; // Yellow
            else healthColor = '#ff0000'; // Red

            ctx.fillStyle = healthColor;
            ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

            // Health bar border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Health text
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText(`Health: ${ship.currentHealth.toFixed(0)}/${config.ship.maxHealth}`, barX, barY - 5);

            // Afterburner bar
            const energyPercent = ship.afterburnerEnergy / config.ship.afterburnerMax;
            const energyBarY = barY + 30;

            // Afterburner bar background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(barX, energyBarY, barWidth, barHeight);

            // Afterburner bar fill with color coding
            let energyColor;
            if (energyPercent > 0.6) energyColor = '#ffffff'; // White
            else if (energyPercent > 0.3) energyColor = '#00ffff'; // Cyan
            else energyColor = '#0000ff'; // Blue

            ctx.fillStyle = energyColor;
            ctx.fillRect(barX, energyBarY, barWidth * energyPercent, barHeight);

            // Afterburner bar border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, energyBarY, barWidth, barHeight);

            // Afterburner text
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText(`Afterburner: ${ship.afterburnerEnergy.toFixed(0)}/${config.ship.afterburnerMax}`, barX, energyBarY - 5);

            ctx.fillText(`Bullets Fired: ${bulletsFired}`, 10, energyBarY + 50);
            ctx.fillText(`Hit %: ${bulletsFired > 0 ? ((bulletsHit / bulletsFired) * 100).toFixed(1) : 0}%`, 10, energyBarY + 70);

            // Game over
            if (gameState === GAME_STATES.GAME_OVER) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
                ctx.font = '20px Arial';
                ctx.fillText(`Final Score: ${score} (Level ${currentLevel})`, canvas.width / 2, canvas.height / 2 + 40);
                ctx.fillText('Press R to Return to Main Menu', canvas.width / 2, canvas.height / 2 + 80);
            }
        }

        function gameLoop() {
            if (gameState === GAME_STATES.PLAYING) {
                updateShip();
                updateProjectiles();
                updateEnemies();
                updateExplosions();
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('click', () => canvas.focus());
        canvas.tabIndex = 1;

        // Initialize game with config loading
        async function initGame() {
            await loadConfig();
            applyConfig();
            gameLoop(); // Start the render loop, but game stays in START state
        }

        initGame();
    </script>
</body>
</html>